"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("react-dom/client"),n=require("three"),o=require("@react-three/fiber"),a=require("zustand"),i=require("react-merge-refs"),s=require("maath"),l=require("@react-spring/three"),c=require("@use-gesture/react"),u=require("zustand/middleware"),d=require("three-stdlib"),m=require("zustand/shallow"),f=require("troika-three-text"),p=require("suspend-react"),h=require("meshline"),v=require("lodash.pick"),g=require("lodash.omit"),x=require("camera-controls"),y=require("stats.js"),w=require("detect-gpu"),b=require("three-mesh-bvh"),M=require("react-composer"),E=require("lodash.clamp");function S(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function C(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var T=S(e),P=C(t),R=C(r),D=C(n),k=C(o),z=S(a),_=S(i),F=S(m),L=S(v),B=S(g),A=S(x),I=S(y),U=S(M),O=S(E);const V=new n.Vector3,j=new n.Vector3,W=new n.Vector3;function N(e,t,r){const n=V.setFromMatrixPosition(e.matrixWorld);n.project(t);const o=r.width/2,a=r.height/2;return[n.x*o+o,-n.y*a+a]}const G=e=>Math.abs(e)<1e-10?0:e;function H(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=G(t[r]*e.elements[r])+(15!==r?",":")");return r+n}const $=(q=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>H(e,q));var q;const X=(e,t)=>{return H(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],"translate(-50%,-50%)");var r};const Y=P.forwardRef((({children:e,eps:t=.001,style:r,className:a,prepend:i,center:s,fullscreen:l,portal:c,distanceFactor:u,sprite:d=!1,transform:m=!1,occlude:f,onOcclude:p,castShadow:h,receiveShadow:v,material:g,geometry:x,zIndexRange:y=[16777271,0],calculatePosition:w=N,as:b="div",wrapperClass:M,pointerEvents:E="auto",...S},C)=>{const{gl:D,camera:k,scene:z,size:_,raycaster:F,events:L,viewport:B}=o.useThree(),[A]=P.useState((()=>document.createElement(b))),I=P.useRef(),U=P.useRef(null),O=P.useRef(0),H=P.useRef([0,0]),q=P.useRef(null),Y=P.useRef(null),Z=(null==c?void 0:c.current)||L.connected||D.domElement.parentNode,K=P.useRef(null),Q=P.useRef(!1),J=P.useMemo((()=>f&&"blending"!==f||Array.isArray(f)&&f.length&&function(e){return e&&"object"==typeof e&&"current"in e}(f[0])),[f]);P.useLayoutEffect((()=>{const e=D.domElement;f&&"blending"===f?(e.style.zIndex=`${Math.floor(y[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[f]),P.useLayoutEffect((()=>{if(U.current){const e=I.current=R.createRoot(A);if(z.updateMatrixWorld(),m)A.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=w(U.current,k,_);A.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Z&&(i?Z.prepend(A):Z.appendChild(A)),()=>{Z&&Z.removeChild(A),e.unmount()}}}),[Z,m]),P.useLayoutEffect((()=>{M&&(A.className=M)}),[M]);const ee=P.useMemo((()=>m?{position:"absolute",top:0,left:0,width:_.width,height:_.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:s?"translate3d(-50%,-50%,0)":"none",...l&&{top:-_.height/2,left:-_.width/2,width:_.width,height:_.height},...r}),[r,s,l,_,m]),te=P.useMemo((()=>({position:"absolute",pointerEvents:E})),[E]);P.useLayoutEffect((()=>{var t,n;(Q.current=!1,m)?null==(t=I.current)||t.render(P.createElement("div",{ref:q,style:ee},P.createElement("div",{ref:Y,style:te},P.createElement("div",{ref:C,className:a,style:r,children:e})))):null==(n=I.current)||n.render(P.createElement("div",{ref:C,style:ee,className:a,children:e}))}));const re=P.useRef(!0);o.useFrame((e=>{if(U.current){k.updateMatrixWorld(),U.current.updateWorldMatrix(!0,!1);const e=m?H.current:w(U.current,k,_);if(m||Math.abs(O.current-k.zoom)>t||Math.abs(H.current[0]-e[0])>t||Math.abs(H.current[1]-e[1])>t){const t=function(e,t){const r=V.setFromMatrixPosition(e.matrixWorld),n=j.setFromMatrixPosition(t.matrixWorld),o=r.sub(n),a=t.getWorldDirection(W);return o.angleTo(a)>Math.PI/2}(U.current,k);let r=!1;J&&("blending"!==f?r=[z]:Array.isArray(f)&&(r=f.map((e=>e.current))));const o=re.current;if(r){const e=function(e,t,r,n){const o=V.setFromMatrixPosition(e.matrixWorld),a=o.clone();a.project(t),r.setFromCamera(a,t);const i=r.intersectObjects(n,!0);if(i.length){const e=i[0].distance;return o.distanceTo(r.ray.origin)<e}return!0}(U.current,k,F,r);re.current=e&&!t}else re.current=!t;o!==re.current&&(p?p(!re.current):A.style.display=re.current?"block":"none");const a=Math.floor(y[0]/2),i=f?J?[y[0],a]:[a-1,0]:y;if(A.style.zIndex=`${function(e,t,r){if(t instanceof n.PerspectiveCamera||t instanceof n.OrthographicCamera){const n=V.setFromMatrixPosition(e.matrixWorld),o=j.setFromMatrixPosition(t.matrixWorld),a=n.distanceTo(o),i=(r[1]-r[0])/(t.far-t.near),s=r[1]-i*t.far;return Math.round(i*a+s)}}(U.current,k,i)}`,m){const[e,t]=[_.width/2,_.height/2],r=k.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:o,left:a,bottom:i,right:s}=k,l=$(k.matrixWorldInverse),c=n?`scale(${r})translate(${G(-(s+a)/2)}px,${G((o+i)/2)}px)`:`translateZ(${r}px)`;let m=U.current.matrixWorld;d&&(m=k.matrixWorldInverse.clone().transpose().copyPosition(m).scale(U.current.scale),m.elements[3]=m.elements[7]=m.elements[11]=0,m.elements[15]=1),A.style.width=_.width+"px",A.style.height=_.height+"px",A.style.perspective=n?"":`${r}px`,q.current&&Y.current&&(q.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,Y.current.style.transform=X(m,1/((u||10)/400)))}else{const t=void 0===u?1:function(e,t){if(t instanceof n.OrthographicCamera)return t.zoom;if(t instanceof n.PerspectiveCamera){const r=V.setFromMatrixPosition(e.matrixWorld),n=j.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,a=r.distanceTo(n);return 1/(2*Math.tan(o/2)*a)}return 1}(U.current,k)*u;A.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}H.current=e,O.current=k.zoom}}if(!J&&K.current&&!Q.current)if(m){if(q.current){const e=q.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=k;if(t||x)S.scale&&(Array.isArray(S.scale)?S.scale instanceof n.Vector3?K.current.scale.copy(S.scale.clone().divideScalar(1)):K.current.scale.set(1/S.scale[0],1/S.scale[1],1/S.scale[2]):K.current.scale.setScalar(1/S.scale));else{const t=(u||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;K.current.scale.set(r,n,1)}Q.current=!0}}}else{const t=A.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/B.factor,r=t.clientWidth*e,n=t.clientHeight*e;K.current.scale.set(r,n,1),Q.current=!0}K.current.lookAt(e.camera.position)}}));const ne=P.useMemo((()=>({vertexShader:m?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[m]);return P.createElement("group",T.default({},S,{ref:U}),f&&!J&&P.createElement("mesh",{castShadow:h,receiveShadow:v,ref:K},x||P.createElement("planeGeometry",null),g||P.createElement("shaderMaterial",{side:n.DoubleSide,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))}));let Z=0;const K=z.default((e=>(n.DefaultLoadingManager.onStart=(t,r,n)=>{e({active:!0,item:t,loaded:r,total:n,progress:(r-Z)/(n-Z)*100})},n.DefaultLoadingManager.onLoad=()=>{e({active:!1})},n.DefaultLoadingManager.onError=t=>e((e=>({errors:[...e.errors,t]}))),n.DefaultLoadingManager.onProgress=(t,r,n)=>{r===n&&(Z=n),e({active:!0,item:t,loaded:r,total:n,progress:(r-Z)/(n-Z)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}))),Q=e=>`Loading ${e.toFixed(2)}%`;const J={container:{position:"absolute",top:0,left:0,width:"100%",height:"100%",background:"#171717",display:"flex",alignItems:"center",justifyContent:"center",transition:"opacity 300ms ease",zIndex:1e3},inner:{width:100,height:3,background:"#272727",textAlign:"center"},bar:{height:3,width:"100%",background:"white",transition:"transform 200ms",transformOrigin:"left center"},data:{display:"inline-block",position:"relative",fontVariantNumeric:"tabular-nums",marginTop:"0.8em",color:"#f0f0f0",fontSize:"0.6em",fontFamily:'-apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Helvetica Neue", Helvetica, Arial, Roboto, Ubuntu, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',whiteSpace:"nowrap"}},ee=P.createContext(null);function te(){return P.useContext(ee)}const re=P.forwardRef((({children:e},t)=>{const r=P.useRef(null),n=te(),{width:a,height:i}=o.useThree((e=>e.viewport));return o.useFrame((()=>{r.current.position.x=n.horizontal?-a*(n.pages-1)*n.offset:0,r.current.position.y=n.horizontal?0:i*(n.pages-1)*n.offset})),P.createElement("group",{ref:_.default([t,r])},e)})),ne=P.forwardRef((({children:e,style:t,...r},n)=>{const a=te(),i=P.useRef(null),{width:s,height:l}=o.useThree((e=>e.size)),c=P.useContext(o.context),u=P.useMemo((()=>R.createRoot(a.fixed)),[a.fixed]);return o.useFrame((()=>{a.delta>a.eps&&(i.current.style.transform=`translate3d(${a.horizontal?-s*(a.pages-1)*a.offset:0}px,${a.horizontal?0:l*(a.pages-1)*-a.offset}px,0)`)})),u.render(P.createElement("div",T.default({ref:_.default([n,i]),style:{...t,position:"absolute",top:0,left:0,willChange:"transform"}},r),P.createElement(ee.Provider,{value:a},P.createElement(o.context.Provider,{value:c},e)))),null})),oe=P.forwardRef((({html:e,...t},r)=>{const n=e?ne:re;return P.createElement(n,T.default({ref:r},t))}));const ae=P.createContext(null);const ie=P.createContext([]);const se=P.forwardRef((function({follow:e=!0,lockX:t=!1,lockY:r=!1,lockZ:n=!1,...a},i){const s=P.useRef();return o.useFrame((({camera:o})=>{if(!e||!s.current)return;const a=s.current.rotation.clone();o.getWorldQuaternion(s.current.quaternion),t&&(s.current.rotation.x=a.x),r&&(s.current.rotation.y=a.y),n&&(s.current.rotation.z=a.z)})),P.createElement("group",T.default({ref:_.default([s,i])},a))})),le=P.forwardRef((({children:e,depth:t=-1,...r},n)=>{const a=P.useRef(null);return o.useFrame((({camera:e})=>{a.current.quaternion.copy(e.quaternion),a.current.position.copy(e.position)})),P.createElement("group",T.default({ref:_.default([n,a])},r),P.createElement("group",{"position-z":-t},e))})),ce=P.forwardRef((function({points:e,color:t="black",vertexColors:r,linewidth:a,lineWidth:i,segments:s,dashed:l,...c},u){const m=o.useThree((e=>e.size)),f=P.useMemo((()=>s?new d.LineSegments2:new d.Line2),[s]),[p]=P.useState((()=>new d.LineMaterial)),h=P.useMemo((()=>{const t=s?new d.LineSegmentsGeometry:new d.LineGeometry,o=e.map((e=>{const t=Array.isArray(e);return e instanceof n.Vector3?[e.x,e.y,e.z]:e instanceof n.Vector2?[e.x,e.y,0]:t&&3===e.length?[e[0],e[1],e[2]]:t&&2===e.length?[e[0],e[1],0]:e}));if(t.setPositions(o.flat()),r){const e=r.map((e=>e instanceof n.Color?e.toArray():e));t.setColors(e.flat())}return t}),[e,s,r]);return P.useLayoutEffect((()=>{f.computeLineDistances()}),[e,f]),P.useLayoutEffect((()=>{l?p.defines.USE_DASH="":delete p.defines.USE_DASH,p.needsUpdate=!0}),[l,p]),P.useEffect((()=>()=>h.dispose()),[h]),P.createElement("primitive",T.default({object:f,ref:u},c),P.createElement("primitive",{object:h,attach:"geometry"}),P.createElement("primitive",T.default({object:p,attach:"material",color:t,vertexColors:Boolean(r),resolution:[m.width,m.height],linewidth:null!=a?a:i,dashed:l},c)))})),ue=new n.Vector3,de=P.forwardRef((function({start:e=[0,0,0],end:t=[0,0,0],mid:r,segments:o=20,...a},i){const s=P.useRef(null),[l]=P.useState((()=>new n.QuadraticBezierCurve3(void 0,void 0,void 0))),c=P.useCallback(((e,t,r,o=20)=>(e instanceof n.Vector3?l.v0.copy(e):l.v0.set(...e),t instanceof n.Vector3?l.v2.copy(t):l.v2.set(...t),r instanceof n.Vector3?l.v1.copy(r):Array.isArray(r)?l.v1.set(...r):l.v1.copy(l.v0.clone().add(l.v2.clone().sub(l.v0)).add(ue.set(0,l.v0.y-l.v2.y,0))),l.getPoints(o))),[]);P.useLayoutEffect((()=>{s.current.setPoints=(e,t,r)=>{const n=c(e,t,r);s.current.geometry&&s.current.geometry.setPositions(n.map((e=>e.toArray())).flat())}}),[]);const u=P.useMemo((()=>c(e,t,r,o)),[e,t,r,o]);return P.createElement(ce,T.default({ref:_.default([s,i]),points:u},a))})),me=P.forwardRef((function({start:e,end:t,midA:r,midB:o,segments:a=20,...i},s){const l=P.useMemo((()=>{const i=e instanceof n.Vector3?e:new n.Vector3(...e),s=t instanceof n.Vector3?t:new n.Vector3(...t),l=r instanceof n.Vector3?r:new n.Vector3(...r),c=o instanceof n.Vector3?o:new n.Vector3(...o);return new n.CubicBezierCurve3(i,l,c,s).getPoints(a)}),[e,t,r,o,a]);return P.createElement(ce,T.default({ref:s,points:l},i))})),fe=P.forwardRef((function({points:e,closed:t=!1,curveType:r="centripetal",tension:o=.5,segments:a=20,vertexColors:i,...s},l){const c=P.useMemo((()=>{const a=e.map((e=>e instanceof n.Vector3?e:new n.Vector3(...e)));return new n.CatmullRomCurve3(a,t,r,o)}),[e,t,r,o]),u=P.useMemo((()=>c.getPoints(a)),[c,a]),d=P.useMemo((()=>{if(!i||i.length<2)return;if(i.length===a+1)return i;const e=i.map((e=>e instanceof n.Color?e:new n.Color(...e)));t&&e.push(e[0].clone());const r=[e[0]],o=a/(e.length-1);for(let t=1;t<a;t++){const n=t%o/o,a=Math.floor(t/o);r.push(e[a].clone().lerp(e[a+1],n))}return r.push(e[e.length-1]),r}),[i,a]);return P.createElement(ce,T.default({ref:l,points:u,vertexColors:d},s))})),pe=P.forwardRef((({url:e,distance:t=1,loop:r=!0,autoplay:a,...i},s)=>{const l=P.useRef(),c=o.useThree((({camera:e})=>e)),[u]=P.useState((()=>new n.AudioListener)),d=o.useLoader(n.AudioLoader,e);return P.useEffect((()=>{const e=l.current;e&&(e.setBuffer(d),e.setRefDistance(t),e.setLoop(r),a&&!e.isPlaying&&e.play())}),[d,c,t,r]),P.useEffect((()=>{const e=l.current;return c.add(u),()=>{c.remove(u),e&&(e.isPlaying&&e.stop(),e.source&&e.source._connected&&e.disconnect())}}),[]),P.createElement("positionalAudio",T.default({ref:_.default([l,s]),args:[u]},i))})),he=P.forwardRef((({anchorX:e="center",anchorY:t="middle",font:r,fontSize:n=1,children:a,characters:i,onSync:s,...l},c)=>{const u=o.useThree((({invalidate:e})=>e)),[d]=P.useState((()=>new f.Text)),[m,h]=P.useMemo((()=>{const e=[];let t="";return P.Children.forEach(a,(r=>{"string"==typeof r||"number"==typeof r?t+=r:e.push(r)})),[e,t]}),[a]);return p.suspend((()=>new Promise((e=>f.preloadFont({font:r,characters:i},e)))),["troika-text",r,i]),P.useLayoutEffect((()=>{d.sync((()=>{u(),s&&s(d)}))})),P.useEffect((()=>()=>d.dispose()),[d]),P.createElement("primitive",T.default({object:d,ref:c,font:r,text:h,anchorX:e,anchorY:t,fontSize:n},l),m)})),ve=["string","number"],ge=P.forwardRef((({font:e,letterSpacing:r=0,lineHeight:n=1,size:a=1,height:i=.2,bevelThickness:s=.1,bevelSize:l=.01,bevelEnabled:c=!1,bevelOffset:u=0,bevelSegments:m=4,curveSegments:f=8,smooth:h,children:v,...g},x)=>{P.useMemo((()=>o.extend({RenamedTextGeometry:d.TextGeometry})),[]);const y=P.useRef(null),w=p.suspend((async()=>{let t="string"==typeof e?await(await fetch(e)).json():e;return(new d.FontLoader).parse(t)}),[e]),b=t.useMemo((()=>({font:w,size:a,height:i,bevelThickness:s,bevelSize:l,bevelEnabled:c,bevelSegments:m,bevelOffset:u,curveSegments:f,letterSpacing:r,lineHeight:n})),[w,a,i,s,l,c,m,u,f,r,n]),[M,...E]=t.useMemo((()=>(e=>{let t="";const r=[];return P.Children.forEach(e,(e=>{ve.includes(typeof e)?t+=e+"":r.push(e)})),[t,...r]})(v)),[v]),S=P.useMemo((()=>[M,b]),[M,b]);return P.useLayoutEffect((()=>{h&&(y.current.geometry=d.mergeVertices(y.current.geometry,h),y.current.geometry.computeVertexNormals())}),[S,h]),P.useImperativeHandle(x,(()=>y.current),[]),P.createElement("mesh",T.default({},g,{ref:y}),P.createElement("renamedTextGeometry",{args:S}),E)})),xe=P.forwardRef((({children:e,multisamping:t=8,renderIndex:r=1,disableRender:a,disableGamma:i,disableRenderPass:s,depthBuffer:l=!0,stencilBuffer:c=!1,anisotropy:u=1,encoding:m,type:f,...p},h)=>{P.useMemo((()=>o.extend({EffectComposer:d.EffectComposer,RenderPass:d.RenderPass,ShaderPass:d.ShaderPass})),[]);const v=P.useRef(),{scene:g,camera:x,gl:y,size:w,viewport:b}=o.useThree(),[M]=P.useState((()=>{const e=new n.WebGLRenderTarget(w.width,w.height,{type:f||n.HalfFloatType,format:n.RGBAFormat,encoding:m||y.outputEncoding,depthBuffer:l,stencilBuffer:c,anisotropy:u});return e.samples=t,e}));P.useEffect((()=>{var e,t;null==(e=v.current)||e.setSize(w.width,w.height),null==(t=v.current)||t.setPixelRatio(b.dpr)}),[y,w,b.dpr]),o.useFrame((()=>{var e;a||null==(e=v.current)||e.render()}),r);const E=[];return s||E.push(P.createElement("renderPass",{key:"renderpass",attach:`passes-${E.length}`,args:[g,x]})),i||E.push(P.createElement("shaderPass",{attach:`passes-${E.length}`,key:"gammapass",args:[d.GammaCorrectionShader]})),P.Children.forEach(e,(e=>{e&&E.push(P.cloneElement(e,{key:E.length,attach:`passes-${E.length}`}))})),P.createElement("effectComposer",T.default({ref:_.default([h,v]),args:[y,M]},p),E)}));function ye(e,t,r,n){const o=class extends D.ShaderMaterial{constructor(o={}){const a=Object.entries(e);super({uniforms:a.reduce(((e,[t,r])=>({...e,...D.UniformsUtils.clone({[t]:{value:r}})})),{}),vertexShader:t,fragmentShader:r}),this.key="",a.forEach((([e])=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t}))),Object.assign(this,o),n&&n(this)}};return o.key=D.MathUtils.generateUUID(),o}const we=e=>e===Object(e)&&!Array.isArray(e)&&"function"!=typeof e;function be(e,r){const a=o.useThree((e=>e.gl)),i=o.useLoader(n.TextureLoader,we(e)?Object.values(e):e);if(t.useLayoutEffect((()=>{null==r||r(i)}),[r]),t.useEffect((()=>{(Array.isArray(i)?i:[i]).forEach(a.initTexture)}),[a,i]),we(e)){const t=Object.keys(e),r={};return t.forEach((e=>Object.assign(r,{[e]:i[t.indexOf(e)]}))),r}return i}be.preload=e=>o.useLoader.preload(n.TextureLoader,e),be.clear=e=>o.useLoader.clear(n.TextureLoader,e);const Me=ye({color:new D.Color("white"),scale:[1,1],imageBounds:[1,1],map:null,zoom:1,grayscale:0,opacity:1},"\n  varying vec2 vUv;\n  void main() {\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n    vUv = uv;\n  }\n","\n  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\n  varying vec2 vUv;\n  uniform vec2 scale;\n  uniform vec2 imageBounds;\n  uniform vec3 color;\n  uniform sampler2D map;\n  uniform float zoom;\n  uniform float grayscale;\n  uniform float opacity;\n  const vec3 luma = vec3(.299, 0.587, 0.114);\n  vec4 toGrayscale(vec4 color, float intensity) {\n    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);\n  }\n  vec2 aspect(vec2 size) {\n    return size / min(size.x, size.y);\n  }\n  void main() {\n    vec2 s = aspect(scale);\n    vec2 i = aspect(imageBounds);\n    float rs = s.x / s.y;\n    float ri = i.x / i.y;\n    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);\n    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;\n    vec2 uv = vUv * s / new + offset;\n    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);\n    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity), grayscale);\n    \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n  }\n"),Ee=P.forwardRef((({children:e,color:t,segments:r=1,scale:n=1,zoom:a=1,grayscale:i=0,opacity:s=1,texture:l,toneMapped:c,transparent:u,...d},m)=>{o.extend({ImageMaterial:Me});const f=o.useThree((e=>e.gl)),p=Array.isArray(n)?[n[0],n[1]]:[n,n],h=[l.image.width,l.image.height];return P.createElement("mesh",T.default({ref:m,scale:Array.isArray(n)?[...n,1]:n},d),P.createElement("planeGeometry",{args:[1,1,r,r]}),P.createElement("imageMaterial",{color:t,map:l,"map-encoding":f.outputEncoding,zoom:a,grayscale:i,opacity:s,scale:p,imageBounds:h,toneMapped:c,transparent:u}),e)})),Se=P.forwardRef((({url:e,...t},r)=>{const n=be(e);return P.createElement(Ee,T.default({},t,{texture:n,ref:r}))})),Ce=P.forwardRef((({url:e,...t},r)=>P.createElement(Ee,T.default({},t,{ref:r})))),Te=P.forwardRef(((e,t)=>{if(e.url)return P.createElement(Se,T.default({},e,{ref:t}));if(e.texture)return P.createElement(Ce,T.default({},e,{ref:t}));throw new Error("<Image /> requires a url or texture")})),Pe=P.forwardRef((({userData:e,children:t,geometry:r,threshold:n=15,color:o="black",...a},i)=>{const s=P.useRef(null);return P.useLayoutEffect((()=>{const e=s.current.parent;if(e){const t=r||e.geometry;t===s.current.userData.currentGeom&&n===s.current.userData.currentThreshold||(s.current.userData.currentGeom=t,s.current.userData.currentThreshold=n,s.current.geometry=new D.EdgesGeometry(t,n))}})),P.useImperativeHandle(i,(()=>s.current)),P.createElement("lineSegments",T.default({ref:s,raycast:()=>null},a),t||P.createElement("lineBasicMaterial",{color:o}))})),Re={width:.2,length:1,decay:1,local:!1,stride:0,interval:1},De=(e,t=1)=>(e.set(e.subarray(t)),e.fill(-1/0,-t),e);function ke(e,t){const{length:r,local:a,decay:i,interval:s,stride:l}={...Re,...t},c=P.useRef(),[u]=P.useState((()=>new n.Vector3));P.useLayoutEffect((()=>{e&&(c.current=Float32Array.from({length:10*r*3},((t,r)=>e.position.getComponent(r%3))))}),[r,e]);const d=P.useRef(new n.Vector3),m=P.useRef(0);return o.useFrame((()=>{if(e&&c.current){if(0===m.current){let t;a?t=e.position:(e.getWorldPosition(u),t=u);const r=1*i;for(let e=0;e<r;e++)t.distanceTo(d.current)<l||(De(c.current,3),c.current.set(t.toArray(),c.current.length-3));d.current.copy(t)}m.current++,m.current=m.current%s}})),c}const ze=P.forwardRef(((e,t)=>{const{children:r}=e,{width:a,length:i,decay:s,local:l,stride:c,interval:u}={...Re,...e},{color:d="hotpink",attenuation:m,target:f}=e,p=o.useThree((e=>e.size)),v=o.useThree((e=>e.scene)),g=P.useRef(null),[x,y]=P.useState(null),w=ke(x,{length:i,decay:s,local:l,stride:c,interval:u});P.useEffect((()=>{const e=(null==f?void 0:f.current)||g.current.children.find((e=>e instanceof n.Object3D));e&&y(e)}),[w,f]);const b=P.useMemo((()=>new h.MeshLineGeometry),[]),M=P.useMemo((()=>{var e;const t=new h.MeshLineMaterial({lineWidth:.1*a,color:d,sizeAttenuation:1,resolution:new n.Vector2(p.width,p.height)});let o;if(r)if(Array.isArray(r))o=r.find((e=>{const t=e;return"string"==typeof t.type&&"meshLineMaterial"===t.type}));else{const e=r;"string"==typeof e.type&&"meshLineMaterial"===e.type&&(o=e)}return"object"==typeof(null==(e=o)?void 0:e.props)&&t.setValues(o.props),t}),[a,d,p,r]);return P.useEffect((()=>{M.uniforms.resolution.value.set(p.width,p.height)}),[p]),o.useFrame((()=>{w.current&&b.setPoints(w.current,m)})),P.createElement("group",null,o.createPortal(P.createElement("mesh",{ref:t,geometry:b,material:M}),v),P.createElement("group",{ref:g},r))}));function _e(e,t=16,r,o,a){const[i,s]=P.useState((()=>{const e=Array.from({length:t},(()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])).flat();return new n.InstancedBufferAttribute(Float32Array.from(e),16)}));return P.useLayoutEffect((()=>{if(void 0===e.current)return;const l=new d.MeshSurfaceSampler(e.current);o&&l.setWeightAttribute(o),l.build();const c=new n.Vector3,u=new n.Vector3,m=new n.Color,f=new n.Object3D;e.current.updateMatrixWorld(!0);for(let n=0;n<t;n++)l.sample(c,u,m),"function"==typeof r?r({dummy:f,sampledMesh:e.current,position:c,normal:u,color:m},n):f.position.copy(c),f.updateMatrix(),null!=a&&a.current&&a.current.setMatrixAt(n,f.matrix),f.matrix.toArray(i.array,16*n);null!=a&&a.current&&(a.current.instanceMatrix.needsUpdate=!0),i.needsUpdate=!0,s(i.clone())}),[e,a,o,t,r]),i}const Fe=P.forwardRef((({isChild:e=!1,object:t,children:r,deep:n,castShadow:o,receiveShadow:a,inject:i,keys:s,...l},c)=>{var u;const m={keys:s,deep:n,inject:i,castShadow:o,receiveShadow:a};if(t=P.useMemo((()=>{if(!1===e&&!Array.isArray(t)){let e=!1;if(t.traverse((t=>{t.isSkinnedMesh&&(e=!0)})),e)return d.SkeletonUtils.clone(t)}return t}),[t,e]),Array.isArray(t))return P.createElement("group",T.default({},l,{ref:c}),t.map((e=>P.createElement(Fe,T.default({key:e.uuid,object:e},m)))),r);const{children:f,...p}=function(e,{keys:t=["near","far","color","distance","decay","penumbra","angle","intensity","skeleton","visible","castShadow","receiveShadow","morphTargetDictionary","morphTargetInfluences","name","geometry","material","position","rotation","scale","up","userData","bindMode","bindMatrix","bindMatrixInverse","skeleton"],deep:r,inject:n,castShadow:o,receiveShadow:a}){let i=L.default(e,t);return r&&(i.geometry&&"materialsOnly"!==r&&(i.geometry=i.geometry.clone()),i.material&&"geometriesOnly"!==r&&(i.material=i.material.clone())),n&&(i="function"==typeof n?{...i,children:n(e)}:P.isValidElement(n)?{...i,children:n}:{...i,...n}),e instanceof D.Mesh&&(o&&(i.castShadow=!0),a&&(i.receiveShadow=!0)),i}(t,m),h=t.type[0].toLowerCase()+t.type.slice(1);return P.createElement(h,T.default({},p,l,{ref:c}),(null==(u=t)?void 0:u.children).map((e=>"Bone"===e.type?P.createElement("primitive",T.default({key:e.uuid,object:e},m)):P.createElement(Fe,T.default({key:e.uuid,object:e},m,{isChild:!0})))),r,f)})),Le=P.createContext(null),Be=P.forwardRef((({resolution:e=28,maxPolyCount:t=1e4,enableUvs:r=!1,enableColors:n=!1,children:a,...i},s)=>{const l=P.useRef(null),c=P.useMemo((()=>new d.MarchingCubes(e,null,r,n,t)),[e,t,r,n]),u=P.useMemo((()=>({getParent:()=>l})),[]);return o.useFrame((()=>{c.reset()}),-1),P.createElement(P.Fragment,null,P.createElement("primitive",T.default({object:c,ref:_.default([l,s])},i),P.createElement(Le.Provider,{value:u},a)))})),Ae=P.forwardRef((({strength:e=.5,subtract:t=12,color:r,...n},a)=>{const{getParent:i}=P.useContext(Le),s=P.useMemo((()=>i()),[i]),l=P.useRef(),c=new D.Vector3;return o.useFrame((n=>{s.current&&l.current&&(l.current.getWorldPosition(c),s.current.addBall(.5+.5*c.x,.5+.5*c.y,.5+.5*c.z,e,t,r))})),P.createElement("group",T.default({ref:_.default([a,l])},n))})),Ie=P.forwardRef((({planeType:e="x",strength:t=.5,subtract:r=12,...n},a)=>{const{getParent:i}=P.useContext(Le),s=P.useMemo((()=>i()),[i]),l=P.useRef(),c=P.useMemo((()=>"x"===e?"addPlaneX":"y"===e?"addPlaneY":"addPlaneZ"),[e]);return o.useFrame((()=>{s.current&&l.current&&s.current[c](t,r)})),P.createElement("group",T.default({ref:_.default([a,l])},n))}));function Ue(e=[0,0,0]){return function(e){return Array.isArray(e)}(e)?e:e instanceof D.Vector3||e instanceof D.Euler?[e.x,e.y,e.z]:[e,e,e]}const Oe=P.forwardRef((function({debug:e,mesh:t,children:r,position:n,rotation:a,scale:i,...s},l){const c=P.useRef(null);P.useImperativeHandle(l,(()=>c.current));const u=P.useRef(null);return P.useLayoutEffect((()=>{const e=(null==t?void 0:t.current)||c.current.parent,r=c.current;if(!(e instanceof D.Mesh))throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');const s={position:new D.Vector3,rotation:new D.Euler,scale:new D.Vector3(1,1,1)};if(e){o.applyProps(s,{position:n,scale:i});const t=e.matrixWorld.clone();if(e.matrixWorld.identity(),a&&"number"!=typeof a)o.applyProps(s,{rotation:a});else{const t=new D.Object3D;t.position.copy(s.position),t.lookAt(e.position),"number"==typeof a&&t.rotateZ(a),o.applyProps(s,{rotation:t.rotation})}return r.geometry=new d.DecalGeometry(e,s.position,s.rotation,s.scale),u.current&&o.applyProps(u.current,s),e.matrixWorld=t,()=>{r.geometry.dispose()}}}),[t,...Ue(n),...Ue(i),...Ue(a)]),P.createElement("mesh",{ref:c},r||P.createElement("meshStandardMaterial",T.default({transparent:!0,polygonOffset:!0,polygonOffsetFactor:-10},s)),e&&P.createElement("mesh",{ref:u},P.createElement("boxGeometry",null),P.createElement("meshNormalMaterial",{wireframe:!0}),P.createElement("axesHelper",null)))})),Ve=t.forwardRef((function({src:e,skipFill:r,skipStrokes:a,fillMaterial:i,strokeMaterial:s,fillMeshProps:l,strokeMeshProps:c,...u},m){const f=o.useLoader(d.SVGLoader,e.startsWith("<svg")?`data:image/svg+xml;utf8,${e}`:e),p=t.useMemo((()=>a?[]:f.paths.map((e=>{var t;return void 0===(null==(t=e.userData)?void 0:t.style.stroke)||"none"===e.userData.style.stroke?null:e.subPaths.map((t=>d.SVGLoader.pointsToStroke(t.getPoints(),e.userData.style)))}))),[f,a]);return t.useEffect((()=>()=>p.forEach((e=>e&&e.map((e=>e.dispose()))))),[p]),P.createElement("object3D",T.default({ref:m},u),P.createElement("object3D",{scale:[1,-1,1]},f.paths.map(((e,o)=>{var u,m;return P.createElement(t.Fragment,{key:o},!r&&void 0!==(null==(u=e.userData)?void 0:u.style.fill)&&"none"!==e.userData.style.fill&&d.SVGLoader.createShapes(e).map(((t,r)=>P.createElement("mesh",T.default({key:r},l),P.createElement("shapeGeometry",{args:[t]}),P.createElement("meshBasicMaterial",T.default({color:e.userData.style.fill,opacity:e.userData.style.fillOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},i))))),!a&&void 0!==(null==(m=e.userData)?void 0:m.style.stroke)&&"none"!==e.userData.style.stroke&&e.subPaths.map(((t,r)=>P.createElement("mesh",T.default({key:r,geometry:p[o][r]},c),P.createElement("meshBasicMaterial",T.default({color:e.userData.style.stroke,opacity:e.userData.style.strokeOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},s))))))}))))}));let je=null;function We(e,t,r){return n=>{r&&r(n),e&&(je||(je=new d.DRACOLoader),je.setDecoderPath("string"==typeof e?e:"https://www.gstatic.com/draco/versioned/decoders/1.5.5/"),n.setDRACOLoader(je)),t&&n.setMeshoptDecoder("function"==typeof d.MeshoptDecoder?d.MeshoptDecoder():d.MeshoptDecoder)}}function Ne(e,t=!0,r=!0,n){return o.useLoader(d.GLTFLoader,e,We(t,r,n))}Ne.preload=(e,t=!0,r=!0,n)=>o.useLoader.preload(d.GLTFLoader,e,We(t,r,n)),Ne.clear=e=>o.useLoader.clear(d.GLTFLoader,e);const Ge=P.forwardRef((({src:e,...t},r)=>{const{scene:n}=Ne(e);return P.createElement(Fe,T.default({ref:r},t,{object:n}))}));function He(e,t,r){const{gl:n,size:a,viewport:i}=o.useThree(),s="number"==typeof e?e:a.width*i.dpr,l="number"==typeof t?t:a.height*i.dpr,c=("number"==typeof e?r:e)||{},{samples:u=0,depth:d,...m}=c,f=P.useMemo((()=>{let e;return e=new D.WebGLRenderTarget(s,l,{minFilter:D.LinearFilter,magFilter:D.LinearFilter,encoding:n.outputEncoding,type:D.HalfFloatType,...m}),d&&(e.depthTexture=new D.DepthTexture(s,l,D.FloatType)),e.samples=u,e}),[]);return P.useLayoutEffect((()=>{f.setSize(s,l),u&&(f.samples=u)}),[u,f,s,l]),P.useEffect((()=>()=>f.dispose()),[]),f}const $e=P.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,children:n,makeDefault:a,...i},s)=>{const l=o.useThree((({set:e})=>e)),c=o.useThree((({camera:e})=>e)),u=o.useThree((({size:e})=>e)),d=P.useRef(null),m=P.useRef(null),f=He(t);P.useLayoutEffect((()=>{i.manual||d.current.updateProjectionMatrix()}),[u,i]),P.useLayoutEffect((()=>{d.current.updateProjectionMatrix()})),P.useLayoutEffect((()=>{if(a){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,a,l]);let p=0,h=null;const v="function"==typeof n;return o.useFrame((t=>{v&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),P.createElement(P.Fragment,null,P.createElement("orthographicCamera",T.default({left:u.width/-2,right:u.width/2,top:u.height/2,bottom:u.height/-2,ref:_.default([d,s])},i),!v&&n),P.createElement("group",{ref:m},v&&n(f.texture)))})),qe=P.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,makeDefault:n,children:a,...i},s)=>{const l=o.useThree((({set:e})=>e)),c=o.useThree((({camera:e})=>e)),u=o.useThree((({size:e})=>e)),d=P.useRef(null),m=P.useRef(null),f=He(t);P.useLayoutEffect((()=>{i.manual||(d.current.aspect=u.width/u.height)}),[u,i]),P.useLayoutEffect((()=>{d.current.updateProjectionMatrix()}));let p=0,h=null;const v="function"==typeof a;return o.useFrame((t=>{v&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),P.useLayoutEffect((()=>{if(n){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,n,l]),P.createElement(P.Fragment,null,P.createElement("perspectiveCamera",T.default({ref:_.default([d,s])},i),!v&&a),P.createElement("group",{ref:m},v&&a(f.texture)))}));function Xe({resolution:e=256,near:r=.1,far:a=1e3,envMap:i,fog:s}={}){const l=o.useThree((({gl:e})=>e)),c=o.useThree((({scene:e})=>e)),u=t.useMemo((()=>{const t=new n.WebGLCubeRenderTarget(e);return t.texture.encoding=l.outputEncoding,t.texture.type=n.HalfFloatType,t}),[e,l.outputEncoding]);t.useEffect((()=>()=>{u.dispose()}),[u]);const d=t.useMemo((()=>new D.CubeCamera(r,a,u)),[r,a,u]);let m,f;const p=P.useCallback((()=>{m=c.fog,f=c.background,c.background=i||f,c.fog=s||m,d.update(l,c),c.fog=m,c.background=f}),[l,c,d]);return{fbo:u,camera:d,update:p}}const Ye=P.forwardRef(((e,t)=>{const{camera:r,onChange:n,makeDefault:a,...i}=e,s=o.useThree((e=>e.camera)),l=o.useThree((e=>e.invalidate)),c=o.useThree((e=>e.get)),u=o.useThree((e=>e.set)),m=r||s,[f]=P.useState((()=>new d.DeviceOrientationControls(m)));return P.useEffect((()=>{const e=e=>{l(),n&&n(e)};return null==f||null==f.addEventListener||f.addEventListener("change",e),()=>null==f||null==f.removeEventListener?void 0:f.removeEventListener("change",e)}),[n,f,l]),o.useFrame((()=>null==f?void 0:f.update()),-1),P.useEffect((()=>{const e=f;return null==e||e.connect(),()=>null==e?void 0:e.dispose()}),[f]),P.useEffect((()=>{if(a){const e=c().controls;return u({controls:f}),()=>u({controls:e})}}),[a,f]),f?P.createElement("primitive",T.default({ref:t,object:f},i)):null})),Ze=P.forwardRef((({domElement:e,...t},r)=>{const{onChange:n,makeDefault:a,...i}=t,s=o.useThree((e=>e.invalidate)),l=o.useThree((e=>e.camera)),c=o.useThree((e=>e.gl)),u=o.useThree((e=>e.events)),m=o.useThree((e=>e.get)),f=o.useThree((e=>e.set)),p=e||u.connected||c.domElement,h=P.useMemo((()=>new d.FlyControls(l)),[l]);return P.useEffect((()=>(h.connect(p),()=>{h.dispose()})),[p,h,s]),P.useEffect((()=>{const e=e=>{s(),n&&n(e)};return null==h.addEventListener||h.addEventListener("change",e),()=>null==h.removeEventListener?void 0:h.removeEventListener("change",e)}),[n,s]),P.useEffect((()=>{if(a){const e=m().controls;return f({controls:h}),()=>f({controls:e})}}),[a,h]),o.useFrame(((e,t)=>h.update(t))),P.createElement("primitive",T.default({ref:r,object:h,args:[l,p]},i))})),Ke=P.forwardRef(((e={enableDamping:!0},t)=>{const{domElement:r,camera:n,makeDefault:a,onChange:i,onStart:s,onEnd:l,...c}=e,u=o.useThree((e=>e.invalidate)),m=o.useThree((e=>e.camera)),f=o.useThree((e=>e.gl)),p=o.useThree((e=>e.events)),h=o.useThree((e=>e.set)),v=o.useThree((e=>e.get)),g=r||p.connected||f.domElement,x=n||m,y=P.useMemo((()=>new d.MapControls(x)),[x]);return P.useEffect((()=>{y.connect(g);const e=e=>{u(),i&&i(e)};return y.addEventListener("change",e),s&&y.addEventListener("start",s),l&&y.addEventListener("end",l),()=>{y.dispose(),y.removeEventListener("change",e),s&&y.removeEventListener("start",s),l&&y.removeEventListener("end",l)}}),[i,s,l,y,u,g]),P.useEffect((()=>{if(a){const e=v().controls;return h({controls:y}),()=>h({controls:e})}}),[a,y]),o.useFrame((()=>y.update()),-1),P.createElement("primitive",T.default({ref:t,object:y,enableDamping:!0},c))})),Qe=P.forwardRef((({makeDefault:e,camera:t,regress:r,domElement:n,enableDamping:a=!0,onChange:i,onStart:s,onEnd:l,...c},u)=>{const m=o.useThree((e=>e.invalidate)),f=o.useThree((e=>e.camera)),p=o.useThree((e=>e.gl)),h=o.useThree((e=>e.events)),v=o.useThree((e=>e.setEvents)),g=o.useThree((e=>e.set)),x=o.useThree((e=>e.get)),y=o.useThree((e=>e.performance)),w=t||f,b=n||h.connected||p.domElement,M=P.useMemo((()=>new d.OrbitControls(w)),[w]);return o.useFrame((()=>{M.enabled&&M.update()}),-1),P.useEffect((()=>(M.connect(b),()=>{M.dispose()})),[b,r,M,m]),P.useEffect((()=>{const e=e=>{m(),r&&y.regress(),i&&i(e)},t=e=>{s&&s(e)},n=e=>{l&&l(e)};return M.addEventListener("change",e),M.addEventListener("start",t),M.addEventListener("end",n),()=>{M.removeEventListener("start",t),M.removeEventListener("end",n),M.removeEventListener("change",e)}}),[i,s,l,M,m,v]),P.useEffect((()=>{if(e){const e=x().controls;return g({controls:M}),()=>g({controls:e})}}),[e,M]),P.createElement("primitive",T.default({ref:u,object:M,enableDamping:a},c))})),Je=P.forwardRef((({makeDefault:e,camera:t,domElement:r,regress:n,onChange:a,onStart:i,onEnd:s,...l},c)=>{const{invalidate:u,camera:m,gl:f,events:p,set:h,get:v,performance:g,viewport:x}=o.useThree(),y=t||m,w=r||p.connected||f.domElement,b=P.useMemo((()=>new d.TrackballControls(y)),[y]);return o.useFrame((()=>{b.enabled&&b.update()}),-1),P.useEffect((()=>(b.connect(w),()=>{b.dispose()})),[w,n,b,u]),P.useEffect((()=>{const e=e=>{u(),n&&g.regress(),a&&a(e)};return b.addEventListener("change",e),i&&b.addEventListener("start",i),s&&b.addEventListener("end",s),()=>{i&&b.removeEventListener("start",i),s&&b.removeEventListener("end",s),b.removeEventListener("change",e)}}),[a,i,s,b,u]),P.useEffect((()=>{b.handleResize()}),[x]),P.useEffect((()=>{if(e){const e=v().controls;return h({controls:b}),()=>h({controls:e})}}),[e,b]),P.createElement("primitive",T.default({ref:c,object:b},l))})),et=t.forwardRef((({camera:e,makeDefault:r,regress:n,domElement:a,onChange:i,onStart:s,onEnd:l,...c},u)=>{const m=o.useThree((e=>e.invalidate)),f=o.useThree((e=>e.camera)),p=o.useThree((e=>e.gl)),h=o.useThree((e=>e.events)),v=o.useThree((e=>e.set)),g=o.useThree((e=>e.get)),x=o.useThree((e=>e.performance)),y=e||f,w=a||h.connected||p.domElement,b=t.useMemo((()=>new d.ArcballControls(y)),[y]);return o.useFrame((()=>{b.enabled&&b.update()}),-1),t.useEffect((()=>(b.connect(w),()=>{b.dispose()})),[w,n,b,m]),t.useEffect((()=>{const e=e=>{m(),n&&x.regress(),i&&i(e)};return b.addEventListener("change",e),s&&b.addEventListener("start",s),l&&b.addEventListener("end",l),()=>{b.removeEventListener("change",e),s&&b.removeEventListener("start",s),l&&b.removeEventListener("end",l)}}),[i,s,l]),t.useEffect((()=>{if(r){const e=g().controls;return v({controls:b}),()=>v({controls:e})}}),[r,b]),P.createElement("primitive",T.default({ref:u,object:b},c))})),tt=P.forwardRef((({children:e,domElement:t,onChange:r,onMouseDown:n,onMouseUp:a,onObjectChange:i,object:s,makeDefault:l,...c},u)=>{const m=["enabled","axis","mode","translationSnap","rotationSnap","scaleSnap","space","size","showX","showY","showZ"],{camera:f,...p}=c,h=L.default(p,m),v=B.default(p,m),g=o.useThree((e=>e.controls)),x=o.useThree((e=>e.gl)),y=o.useThree((e=>e.events)),w=o.useThree((e=>e.camera)),b=o.useThree((e=>e.invalidate)),M=o.useThree((e=>e.get)),E=o.useThree((e=>e.set)),S=f||w,C=t||y.connected||x.domElement,R=P.useMemo((()=>new d.TransformControls(S,C)),[S,C]),k=P.useRef();P.useLayoutEffect((()=>(s?R.attach(s instanceof D.Object3D?s:s.current):k.current instanceof D.Object3D&&R.attach(k.current),()=>{R.detach()})),[s,e,R]),P.useEffect((()=>{if(g){const e=e=>g.enabled=!e.value;return R.addEventListener("dragging-changed",e),()=>R.removeEventListener("dragging-changed",e)}}),[R,g]);const z=P.useRef(),_=P.useRef(),F=P.useRef(),A=P.useRef();return P.useLayoutEffect((()=>{z.current=r}),[r]),P.useLayoutEffect((()=>{_.current=n}),[n]),P.useLayoutEffect((()=>{F.current=a}),[a]),P.useLayoutEffect((()=>{A.current=i}),[i]),P.useEffect((()=>{const e=e=>{b(),null==z.current||z.current(e)},t=e=>null==_.current?void 0:_.current(e),r=e=>null==F.current?void 0:F.current(e),n=e=>null==A.current?void 0:A.current(e);return R.addEventListener("change",e),R.addEventListener("mouseDown",t),R.addEventListener("mouseUp",r),R.addEventListener("objectChange",n),()=>{R.removeEventListener("change",e),R.removeEventListener("mouseDown",t),R.removeEventListener("mouseUp",r),R.removeEventListener("objectChange",n)}}),[b,R]),P.useEffect((()=>{if(l){const e=M().controls;return E({controls:R}),()=>E({controls:e})}}),[l,R]),R?P.createElement(P.Fragment,null,P.createElement("primitive",T.default({ref:u,object:R},h)),P.createElement("group",T.default({ref:k},v),e)):null})),rt=P.forwardRef((({domElement:e,selector:t,onChange:r,onLock:n,onUnlock:a,enabled:i=!0,makeDefault:s,...l},c)=>{const{camera:u,...m}=l,f=o.useThree((e=>e.setEvents)),p=o.useThree((e=>e.gl)),h=o.useThree((e=>e.camera)),v=o.useThree((e=>e.invalidate)),g=o.useThree((e=>e.events)),x=o.useThree((e=>e.get)),y=o.useThree((e=>e.set)),w=u||h,b=e||g.connected||p.domElement,[M]=P.useState((()=>new d.PointerLockControls(w)));return P.useEffect((()=>{if(i){M.connect(b);const e=x().events.compute;return f({compute(e,t){const r=t.size.width/2,n=t.size.height/2;t.pointer.set(r/t.size.width*2-1,-n/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{M.disconnect(),f({compute:e})}}}),[i,M]),P.useEffect((()=>{const e=e=>{v(),r&&r(e)};M.addEventListener("change",e),n&&M.addEventListener("lock",n),a&&M.addEventListener("unlock",a);const o=()=>M.lock(),i=t?Array.from(document.querySelectorAll(t)):[document];return i.forEach((e=>e&&e.addEventListener("click",o))),()=>{M.removeEventListener("change",e),n&&M.addEventListener("lock",n),a&&M.addEventListener("unlock",a),i.forEach((e=>e?e.removeEventListener("click",o):void 0))}}),[r,n,a,t,M,v]),P.useEffect((()=>{if(s){const e=x().controls;return y({controls:M}),()=>y({controls:e})}}),[s,M]),P.createElement("primitive",T.default({ref:c,object:M},m))})),nt=P.forwardRef((({domElement:e,makeDefault:t,...r},n)=>{const a=o.useThree((e=>e.camera)),i=o.useThree((e=>e.gl)),s=o.useThree((e=>e.events)),l=o.useThree((e=>e.get)),c=o.useThree((e=>e.set)),u=e||s.connected||i.domElement,[m]=P.useState((()=>new d.FirstPersonControls(a,u)));return P.useEffect((()=>{if(t){const e=l().controls;return c({controls:m}),()=>c({controls:e})}}),[t,m]),o.useFrame(((e,t)=>{m.update(t)}),-1),m?P.createElement("primitive",T.default({ref:n,object:m},r)):null})),ot=t.forwardRef(((e,r)=>{t.useMemo((()=>{A.default.install({THREE:D}),o.extend({CameraControlsImpl:A.default})}),[]);const{camera:n,domElement:a,makeDefault:i,onStart:s,onEnd:l,onChange:c,regress:u,...d}=e,m=o.useThree((e=>e.camera)),f=o.useThree((e=>e.gl)),p=o.useThree((e=>e.invalidate)),h=o.useThree((e=>e.events)),v=o.useThree((e=>e.setEvents)),g=o.useThree((e=>e.set)),x=o.useThree((e=>e.get)),y=o.useThree((e=>e.performance)),w=n||m,b=a||h.connected||f.domElement,M=t.useMemo((()=>new A.default(w)),[w]);return o.useFrame(((e,t)=>{M.enabled&&M.update(t)}),-1),t.useEffect((()=>(M.connect(b),()=>{M.disconnect()})),[b,M]),P.useEffect((()=>{const e=e=>{p(),u&&y.regress(),c&&c(e)},t=e=>{s&&s(e)},r=e=>{l&&l(e)};return M.addEventListener("update",e),M.addEventListener("controlstart",t),M.addEventListener("controlend",r),()=>{M.removeEventListener("update",e),M.removeEventListener("controlstart",t),M.removeEventListener("controlend",r)}}),[M,s,l,p,v,u,c]),t.useEffect((()=>{if(i){const e=x().controls;return g({controls:M}),()=>g({controls:e})}}),[i,M]),P.createElement("primitive",T.default({ref:r,object:M},d))}));function at({defaultScene:e,defaultCamera:t,renderPriority:r=1}){const{gl:n,scene:a,camera:i}=o.useThree();let s;return o.useFrame((()=>{s=n.autoClear,1===r&&(n.autoClear=!0,n.render(e,t)),n.autoClear=!1,n.clearDepth(),n.render(a,i),n.autoClear=s}),r),P.createElement(P.Fragment,null)}function it({children:e,renderPriority:t=1}){const{scene:r,camera:n}=o.useThree(),[a]=P.useState((()=>new D.Scene));return P.createElement(P.Fragment,null,o.createPortal(P.createElement(P.Fragment,null,e,P.createElement(at,{defaultScene:r,defaultCamera:n,renderPriority:t})),a,{events:{priority:t+1}}))}const st=P.createContext({}),lt=()=>P.useContext(st),ct=2*Math.PI,ut=new n.Object3D,dt=new n.Matrix4,[mt,ft]=[new n.Quaternion,new n.Quaternion],pt=new n.Vector3,ht=new n.Vector3,vt="#f0f0f0",gt="#999",xt="black",yt="black",wt=["Right","Left","Top","Bottom","Front","Back"],bt=e=>new n.Vector3(...e).multiplyScalar(.38),Mt=[[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]].map(bt),Et=[.25,.25,.25],St=[[1,1,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,1],[0,1,-1],[0,-1,1],[0,-1,-1],[-1,1,0],[-1,0,1],[-1,0,-1],[-1,-1,0]].map(bt),Ct=St.map((e=>e.toArray().map((e=>0==e?.5:.25)))),Tt=({hover:e,index:t,font:r="20px Inter var, Arial, sans-serif",faces:a=wt,color:i=vt,hoverColor:s=gt,textColor:l=xt,strokeColor:c=yt,opacity:u=1})=>{const d=o.useThree((e=>e.gl)),m=P.useMemo((()=>{const e=document.createElement("canvas");e.width=128,e.height=128;const o=e.getContext("2d");return o.fillStyle=i,o.fillRect(0,0,e.width,e.height),o.strokeStyle=c,o.strokeRect(0,0,e.width,e.height),o.font=r,o.textAlign="center",o.fillStyle=l,o.fillText(a[t].toUpperCase(),64,76),new n.CanvasTexture(e)}),[t,a,r,i,l,c]);return P.createElement("meshLambertMaterial",{map:m,"map-encoding":d.outputEncoding,"map-anisotropy":d.capabilities.getMaxAnisotropy()||1,attach:`material-${t}`,color:e?s:"white",transparent:!0,opacity:u})},Pt=e=>{const{tweenCamera:t}=lt(),[r,n]=P.useState(null);return P.createElement("mesh",{onPointerOut:e=>{e.stopPropagation(),n(null)},onPointerMove:e=>{e.stopPropagation(),n(Math.floor(e.faceIndex/2))},onClick:e.onClick||(e=>{e.stopPropagation(),t(e.face.normal)})},[...Array(6)].map(((t,n)=>P.createElement(Tt,T.default({key:n,index:n,hover:r===n},e)))),P.createElement("boxGeometry",null))},Rt=({onClick:e,dimensions:t,position:r,hoverColor:n=gt})=>{const{tweenCamera:o}=lt(),[a,i]=P.useState(!1);return P.createElement("mesh",{scale:1.01,position:r,onPointerOver:e=>{e.stopPropagation(),i(!0)},onPointerOut:e=>{e.stopPropagation(),i(!1)},onClick:e||(e=>{e.stopPropagation(),o(r)})},P.createElement("meshBasicMaterial",{color:a?n:"white",transparent:!0,opacity:.6,visible:a}),P.createElement("boxGeometry",{args:t}))};function Dt({scale:e=[.8,.05,.05],color:t,rotation:r}){return P.createElement("group",{rotation:r},P.createElement("mesh",{position:[.4,0,0]},P.createElement("boxGeometry",{args:e}),P.createElement("meshBasicMaterial",{color:t,toneMapped:!1})))}function kt({onClick:e,font:t,disabled:r,arcStyle:a,label:i,labelColor:s,axisHeadScale:l=1,...c}){const u=o.useThree((e=>e.gl)),d=P.useMemo((()=>{const e=document.createElement("canvas");e.width=64,e.height=64;const r=e.getContext("2d");return r.beginPath(),r.arc(32,32,16,0,2*Math.PI),r.closePath(),r.fillStyle=a,r.fill(),i&&(r.font=t,r.textAlign="center",r.fillStyle=s,r.fillText(i,32,41)),new n.CanvasTexture(e)}),[a,i,s,t]),[m,f]=P.useState(!1),p=(i?1:.75)*(m?1.2:1)*l;return P.createElement("sprite",T.default({scale:p,onPointerOver:r?void 0:e=>{e.stopPropagation(),f(!0)},onPointerOut:r?void 0:e||(e=>{e.stopPropagation(),f(!1)})},c),P.createElement("spriteMaterial",{map:d,"map-encoding":u.outputEncoding,"map-anisotropy":u.capabilities.getMaxAnisotropy()||1,alphaTest:.3,opacity:i?1:.75,toneMapped:!1}))}const zt=ye({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new D.Color,sectionColor:new D.Color,infiniteGrid:0,followCamera:0},"varying vec3 worldPosition;\n   uniform float fadeDistance;\n   uniform float infiniteGrid;\n   uniform float followCamera;\n   void main() {\n     vec3 pos = position.xzy * (1. + fadeDistance * infiniteGrid);\n     pos.xz += (cameraPosition.xz * followCamera);\n     worldPosition = pos;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n   }","varying vec3 worldPosition;\n   uniform float cellSize;\n   uniform float sectionSize;\n   uniform vec3 cellColor;\n   uniform vec3 sectionColor;\n   uniform float fadeDistance;\n   uniform float fadeStrength;\n   uniform float cellThickness;\n   uniform float sectionThickness;\n   uniform float infiniteGrid;\n   float getGrid(float size, float thickness) {\n     vec2 r = worldPosition.xz / size;\n     vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n     float line = min(grid.x, grid.y) + 1. - thickness;\n     return 1.0 - min(line, 1.);\n   }\n   void main() {\n     float g1 = getGrid(cellSize, cellThickness);\n     float g2 = getGrid(sectionSize, sectionThickness);\n     float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / fadeDistance, 1.);\n     vec3 color = mix(cellColor, sectionColor, min(1.,sectionThickness * g2));\n     gl_FragColor = vec4(color, (g1 + g2) * pow(d,fadeStrength));\n     gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n     if (gl_FragColor.a <= 0.0) discard;\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }"),_t=P.forwardRef((({args:e,cellColor:t="#000000",sectionColor:r="#2080ff",cellSize:n=.5,sectionSize:a=1,followCamera:i=!1,infiniteGrid:s=!1,fadeDistance:l=100,fadeStrength:c=1,cellThickness:u=.5,sectionThickness:d=1,side:m=D.BackSide,...f},p)=>{o.extend({GridMaterial:zt});const h={cellSize:n,sectionSize:a,cellColor:t,sectionColor:r,cellThickness:u,sectionThickness:d},v={fadeDistance:l,fadeStrength:c,infiniteGrid:s,followCamera:i};return P.createElement("mesh",T.default({ref:p,frustumCulled:!1},f),P.createElement("gridMaterial",T.default({transparent:!0,"extensions-derivatives":!0,side:m},h,v)),P.createElement("planeGeometry",{args:e}))}));function Ft(e,{path:t}){const[r]=o.useLoader(n.CubeTextureLoader,[e],(e=>e.setPath(t)));return r}function Lt(e){return o.useLoader(d.FBXLoader,e)}Ft.preload=(e,{path:t})=>o.useLoader.preload(n.CubeTextureLoader,[e],(e=>e.setPath(t))),Lt.preload=e=>o.useLoader.preload(d.FBXLoader,e),Lt.clear=e=>o.useLoader.clear(d.FBXLoader,e);const Bt="https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master";function At(e,r=`${Bt}/basis/`){const n=o.useThree((e=>e.gl)),a=o.useLoader(d.KTX2Loader,we(e)?Object.values(e):e,(e=>{e.detectSupport(n),e.setTranscoderPath(r)}));if(t.useEffect((()=>{(Array.isArray(a)?a:[a]).forEach(n.initTexture)}),[n,a]),we(e)){const t=Object.keys(e),r={};return t.forEach((e=>Object.assign(r,{[e]:a[t.indexOf(e)]}))),r}return a}function It(e,t){"function"==typeof e?e(t):null!=e&&(e.current=t)}At.preload=(e,t=`${Bt}/basis/`)=>o.useLoader.preload(d.KTX2Loader,e,(e=>{e.setTranscoderPath(t)})),At.clear=e=>o.useLoader.clear(d.KTX2Loader,e);function Ut(e,t,...r){const n=P.useRef(),a=o.useThree((e=>e.scene));return P.useLayoutEffect((()=>{let o;if(e&&null!=e&&e.current&&t&&(n.current=o=new t(e.current,...r)),o)return a.add(o),()=>{n.current=void 0,a.remove(o),null==o.dispose||o.dispose()}}),[a,t,e,...r]),o.useFrame((()=>{var e;null==(e=n.current)||null==e.update||e.update()})),n}const Ot=e=>e.isMesh;const Vt=P.forwardRef((({enabled:e=!0,firstHitOnly:t=!1,children:r,strategy:a=b.SAH,verbose:i=!1,setBoundingBox:s=!0,maxDepth:l=40,maxLeafTris:c=10,...u},d)=>{const m=P.useRef(null),f=o.useThree((e=>e.raycaster));return P.useImperativeHandle(d,(()=>m.current),[]),P.useEffect((()=>{if(e){const e={strategy:a,verbose:i,setBoundingBox:s,maxDepth:l,maxLeafTris:c},r=m.current;return f.firstHitOnly=t,r.traverse((t=>{Ot(t)&&!t.geometry.boundsTree&&t.raycast===n.Mesh.prototype.raycast&&(t.raycast=b.acceleratedRaycast,t.geometry.computeBoundsTree=b.computeBoundsTree,t.geometry.disposeBoundsTree=b.disposeBoundsTree,t.geometry.computeBoundsTree(e))})),()=>{delete f.firstHitOnly,r.traverse((e=>{Ot(e)&&e.geometry.boundsTree&&(e.geometry.disposeBoundsTree(),e.raycast=n.Mesh.prototype.raycast)}))}}})),P.createElement("group",T.default({ref:m},u),r)}));const jt=new D.Box3,Wt=new D.Vector3;const Nt=e=>Math.sqrt(1-Math.pow(e-1,2));class Gt{constructor({size:e=256,maxAge:t=750,radius:r=.3,intensity:n=.2,interpolate:o=0,smoothing:a=0,minForce:i=.3,blend:s="screen",ease:l=Nt}={}){this.size=e,this.maxAge=t,this.radius=r,this.intensity=n,this.ease=l,this.interpolate=o,this.smoothing=a,this.minForce=i,this.blend=s,this.trail=[],this.force=0,this.initTexture()}initTexture(){this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=this.size,this.ctx=this.canvas.getContext("2d"),this.ctx.fillStyle="black",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.texture=new n.Texture(this.canvas),this.canvas.id="touchTexture",this.canvas.style.width=this.canvas.style.height=`${this.canvas.width}px`}update(e){this.clear(),this.trail.forEach(((t,r)=>{t.age+=1e3*e,t.age>this.maxAge&&this.trail.splice(r,1)})),this.trail.length||(this.force=0),this.trail.forEach((e=>{this.drawTouch(e)})),this.texture.needsUpdate=!0}clear(){this.ctx.globalCompositeOperation="source-over",this.ctx.fillStyle="black",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}addTouch(e){const t=this.trail[this.trail.length-1];if(t){const r=t.x-e.x,n=t.y-e.y,o=r*r+n*n,a=Math.max(this.minForce,Math.min(1e4*o,1));if(this.force=function(e,t,r=.9){return t*r+e*(1-r)}(a,this.force,this.smoothing),this.interpolate){const e=Math.ceil(o/Math.pow(.5*this.radius/this.interpolate,2));if(e>1)for(let o=1;o<e;o++)this.trail.push({x:t.x-r/e*o,y:t.y-n/e*o,age:0,force:a})}}this.trail.push({x:e.x,y:e.y,age:0,force:this.force})}drawTouch(e){const t={x:e.x*this.size,y:(1-e.y)*this.size};let r=1;r=e.age<.3*this.maxAge?this.ease(e.age/(.3*this.maxAge)):this.ease(1-(e.age-.3*this.maxAge)/(.7*this.maxAge)),r*=e.force,this.ctx.globalCompositeOperation=this.blend;const n=this.size*this.radius*r,o=this.ctx.createRadialGradient(t.x,t.y,Math.max(0,.25*n),t.x,t.y,Math.max(0,n));o.addColorStop(0,`rgba(255, 255, 255, ${this.intensity})`),o.addColorStop(1,"rgba(0, 0, 0, 0.0)"),this.ctx.beginPath(),this.ctx.fillStyle=o,this.ctx.arc(t.x,t.y,Math.max(0,n),0,2*Math.PI),this.ctx.fill()}}const Ht=P.forwardRef((({children:e,curve:t},r)=>{const[n]=P.useState((()=>new D.Scene)),[a,i]=P.useState(),s=P.useRef();return P.useEffect((()=>{s.current=new d.Flow(n.children[0]),i(s.current.object3D)}),[e]),P.useEffect((()=>{var e;t&&(null==(e=s.current)||e.updateCurve(0,t))}),[t]),P.useImperativeHandle(r,(()=>({moveAlongCurve:e=>{var t;null==(t=s.current)||t.moveAlongCurve(e)}}))),P.createElement(P.Fragment,null,o.createPortal(e,n),a&&P.createElement("primitive",{object:a}))}));class $t extends n.MeshPhysicalMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._distort={value:.4},this._radius={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.radius=this._radius,e.uniforms.distort=this._distort,e.vertexShader=`\n      uniform float time;\n      uniform float radius;\n      uniform float distort;\n      #define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\n      ${e.vertexShader}\n    `,e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","\n        float updateTime = time / 50.0;\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\n        ")}get time(){return this._time.value}set time(e){this._time.value=e}get distort(){return this._distort.value}set distort(e){this._distort.value=e}get radius(){return this._radius.value}set radius(e){this._radius.value=e}}const qt=P.forwardRef((({speed:e=1,...t},r)=>{const[n]=P.useState((()=>new $t));return o.useFrame((t=>n&&(n.time=t.clock.getElapsedTime()*e))),P.createElement("primitive",T.default({object:n,ref:r,attach:"material"},t))}));class Xt extends n.MeshStandardMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._factor={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.factor=this._factor,e.vertexShader=`\n      uniform float time;\n      uniform float factor;\n      ${e.vertexShader}\n    `,e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;")}get time(){return this._time.value}set time(e){this._time.value=e}get factor(){return this._factor.value}set factor(e){this._factor.value=e}}const Yt=P.forwardRef((({speed:e=1,...t},r)=>{const[n]=P.useState((()=>new Xt));return o.useFrame((t=>n&&(n.time=t.clock.getElapsedTime()*e))),P.createElement("primitive",T.default({object:n,ref:r,attach:"material"},t))}));class Zt extends n.ShaderMaterial{constructor(e=new n.Vector2){super({uniforms:{inputBuffer:new n.Uniform(null),depthBuffer:new n.Uniform(null),resolution:new n.Uniform(new n.Vector2),texelSize:new n.Uniform(new n.Vector2),halfTexelSize:new n.Uniform(new n.Vector2),kernel:new n.Uniform(0),scale:new n.Uniform(1),cameraNear:new n.Uniform(0),cameraFar:new n.Uniform(1),minDepthThreshold:new n.Uniform(0),maxDepthThreshold:new n.Uniform(1),depthScale:new n.Uniform(0),depthToBlurRatioBias:new n.Uniform(.25)},fragmentShader:"#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n        }",vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:n.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class Kt{constructor({gl:e,resolution:t,width:r=500,height:o=500,minDepthThreshold:a=0,maxDepthThreshold:i=1,depthScale:s=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new n.WebGLRenderTarget(t,t,{minFilter:n.LinearFilter,magFilter:n.LinearFilter,stencilBuffer:!1,depthBuffer:!1,encoding:e.outputEncoding}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Zt,this.convolutionMaterial.setTexelSize(1/r,1/o),this.convolutionMaterial.setResolution(new n.Vector2(r,o)),this.scene=new n.Scene,this.camera=new n.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=i,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),d=new n.BufferGeometry;d.setAttribute("position",new n.BufferAttribute(c,3)),d.setAttribute("uv",new n.BufferAttribute(u,2)),this.screen=new n.Mesh(d,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,o=this.camera,a=this.renderTargetA,i=this.renderTargetB;let s=this.convolutionMaterial,l=s.uniforms;l.depthBuffer.value=t.depthTexture;const c=s.kernel;let u,d,m,f=t;for(d=0,m=c.length-1;d<m;++d)u=0==(1&d)?a:i,l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(u),e.render(n,o),f=u;l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,o)}}class Qt extends n.MeshStandardMaterial{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}o.extend({MeshReflectorMaterialImpl:Qt});const Jt=P.forwardRef((({mixBlur:e=0,mixStrength:t=1,resolution:r=256,blur:a=[0,0],minDepthThreshold:i=.9,maxDepthThreshold:s=1,depthScale:l=0,depthToBlurRatioBias:c=.25,mirror:u=0,distortion:d=1,mixContrast:m=1,distortionMap:f,reflectorOffset:p=0,...h},v)=>{const g=o.useThree((({gl:e})=>e)),x=o.useThree((({camera:e})=>e)),y=o.useThree((({scene:e})=>e)),w=(a=Array.isArray(a)?a:[a,a])[0]+a[1]>0,b=P.useRef(null),[M]=P.useState((()=>new n.Plane)),[E]=P.useState((()=>new n.Vector3)),[S]=P.useState((()=>new n.Vector3)),[C]=P.useState((()=>new n.Vector3)),[R]=P.useState((()=>new n.Matrix4)),[D]=P.useState((()=>new n.Vector3(0,0,-1))),[k]=P.useState((()=>new n.Vector4)),[z]=P.useState((()=>new n.Vector3)),[F]=P.useState((()=>new n.Vector3)),[L]=P.useState((()=>new n.Vector4)),[B]=P.useState((()=>new n.Matrix4)),[A]=P.useState((()=>new n.PerspectiveCamera)),I=P.useCallback((()=>{var e;const t=b.current.parent||(null==(e=b.current)?void 0:e.__r3f.parent);if(!t)return;if(S.setFromMatrixPosition(t.matrixWorld),C.setFromMatrixPosition(x.matrixWorld),R.extractRotation(t.matrixWorld),E.set(0,0,1),E.applyMatrix4(R),S.addScaledVector(E,p),z.subVectors(S,C),z.dot(E)>0)return;z.reflect(E).negate(),z.add(S),R.extractRotation(x.matrixWorld),D.set(0,0,-1),D.applyMatrix4(R),D.add(C),F.subVectors(S,D),F.reflect(E).negate(),F.add(S),A.position.copy(z),A.up.set(0,1,0),A.up.applyMatrix4(R),A.up.reflect(E),A.lookAt(F),A.far=x.far,A.updateMatrixWorld(),A.projectionMatrix.copy(x.projectionMatrix),B.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),B.multiply(A.projectionMatrix),B.multiply(A.matrixWorldInverse),B.multiply(t.matrixWorld),M.setFromNormalAndCoplanarPoint(E,S),M.applyMatrix4(A.matrixWorldInverse),k.set(M.normal.x,M.normal.y,M.normal.z,M.constant);const r=A.projectionMatrix;L.x=(Math.sign(k.x)+r.elements[8])/r.elements[0],L.y=(Math.sign(k.y)+r.elements[9])/r.elements[5],L.z=-1,L.w=(1+r.elements[10])/r.elements[14],k.multiplyScalar(2/k.dot(L)),r.elements[2]=k.x,r.elements[6]=k.y,r.elements[10]=k.z+1,r.elements[14]=k.w}),[x,p]),[U,O,V,j]=P.useMemo((()=>{const o={minFilter:n.LinearFilter,magFilter:n.LinearFilter,encoding:g.outputEncoding,type:n.HalfFloatType},p=new n.WebGLRenderTarget(r,r,o);p.depthBuffer=!0,p.depthTexture=new n.DepthTexture(r,r),p.depthTexture.format=n.DepthFormat,p.depthTexture.type=n.UnsignedShortType;const h=new n.WebGLRenderTarget(r,r,o);return[p,h,new Kt({gl:g,resolution:r,width:a[0],height:a[1],minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c}),{mirror:u,textureMatrix:B,mixBlur:e,tDiffuse:p.texture,tDepth:p.depthTexture,tDiffuseBlur:h.texture,hasBlur:w,mixStrength:t,minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c,distortion:d,distortionMap:f,mixContrast:m,"defines-USE_BLUR":w?"":void 0,"defines-USE_DEPTH":l>0?"":void 0,"defines-USE_DISTORTION":f?"":void 0}]}),[g,a,B,r,u,w,e,t,i,s,l,c,d,f,m]);return o.useFrame((()=>{var e;const t=b.current.parent||(null==(e=b.current)?void 0:e.__r3f.parent);if(!t)return;t.visible=!1;const r=g.xr.enabled,n=g.shadowMap.autoUpdate;I(),g.xr.enabled=!1,g.shadowMap.autoUpdate=!1,g.setRenderTarget(U),g.state.buffers.depth.setMask(!0),g.autoClear||g.clear(),g.render(y,A),w&&V.render(g,U,O),g.xr.enabled=r,g.shadowMap.autoUpdate=n,t.visible=!0,g.setRenderTarget(null)})),P.createElement("meshReflectorMaterialImpl",T.default({attach:"material",key:"key"+j["defines-USE_BLUR"]+j["defines-USE_DEPTH"]+j["defines-USE_DISTORTION"],ref:_.default([b,v])},j,h))})),er=ye({envMap:null,bounces:3,ior:2.4,correctMips:!0,aberrationStrength:.01,fresnel:0,bvh:new b.MeshBVHUniformStruct,color:new D.Color("white"),resolution:new D.Vector2,viewMatrixInverse:new D.Matrix4,projectionMatrixInverse:new D.Matrix4},"\n  uniform mat4 viewMatrixInverse;\n\n  varying vec3 vWorldPosition;  \n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #ifdef USE_INSTANCING_COLOR\n    varying vec3 vInstanceColor;\n  #endif\n\n  void main() {        \n    vec4 transformedNormal = vec4(normal, 0.0);\n    vec4 transformedPosition = vec4(position, 1.0);\n    #ifdef USE_INSTANCING\n      transformedNormal = instanceMatrix * transformedNormal;\n      transformedPosition = instanceMatrix * transformedPosition;\n    #endif\n\n    #ifdef USE_INSTANCING\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\n    #else\n      vModelMatrixInverse = inverse(modelMatrix);\n    #endif\n\n    #ifdef USE_INSTANCING_COLOR\n      vInstanceColor = instanceColor.rgb;\n    #endif\n\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\n  }",`\n  #define ENVMAP_TYPE_CUBE_UV\n  precision highp isampler2D;\n  precision highp usampler2D;\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #ifdef USE_INSTANCING_COLOR\n    varying vec3 vInstanceColor;\n  #endif\n    \n  #ifdef ENVMAP_TYPE_CUBEM\n    uniform samplerCube envMap;\n  #else\n    uniform sampler2D envMap;\n  #endif\n    \n  uniform float bounces;\n  ${b.shaderStructs}\n  ${b.shaderIntersectFunction}\n  uniform BVH bvh;\n  uniform float ior;\n  uniform bool correctMips;\n  uniform vec2 resolution;\n  uniform float fresnel;\n  uniform mat4 modelMatrix;\n  uniform mat4 projectionMatrixInverse;\n  uniform mat4 viewMatrixInverse;\n  uniform float aberrationStrength;\n  uniform vec3 color;\n  \n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\n  }\n    \n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\n    vec3 rayOrigin = ro;\n    vec3 rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\n    for(float i = 0.0; i < bounces; i++) {\n      uvec4 faceIndices = uvec4( 0u );\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n      vec3 barycoord = vec3( 0.0 );\n      float side = 1.0;\n      float dist = 0.0;\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      \n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\n      if (length(tempDir) != 0.0) {\n        rayDirection = tempDir;\n        break;\n      }\n      rayDirection = reflect(rayDirection, faceNormal);\n      rayOrigin = hitPos + rayDirection * 0.01;\n    }\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\n    return rayDirection;\n  }\n    \n  #include <common>\n  #include <cube_uv_reflection_fragment>\n    \n  #ifdef ENVMAP_TYPE_CUBEM\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\n    }\n  #else\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      vec2 uvv = equirectUv( rayDirection );\n      vec2 smoothUv = equirectUv( directionCamPerfect );\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\n    }\n  #endif\n  \n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\n    directionCamPerfect = normalize(directionCamPerfect);\n    vec3 normal = vNormal;\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n    vec3 finalColor;\n    #ifdef CHROMATIC_ABERRATIONS\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      #ifdef FAST_CHROMA \n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\n      #else\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\n      #endif\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\n      finalColor = vec3(finalColorR, finalColorG, finalColorB);\n    #else\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    \n    #endif\n\n    finalColor *= color;\n    #ifdef USE_INSTANCING_COLOR\n      finalColor *= vInstanceColor;\n    #endif\n\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n  }`);const tr=ye({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");class rr extends D.MeshPhysicalMaterial{constructor(e=6,t=!1){super(),this.uniforms={chromaticAberration:{value:.05},transmission:{value:0},_transmission:{value:1},transmissionMap:{value:null},roughness:{value:0},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:1/0},attenuationColor:{value:new D.Color("white")},anisotropy:{value:.1},time:{value:0},distortion:{value:0},distortionScale:{value:.5},temporalDistortion:{value:0},buffer:{value:null}},this.onBeforeCompile=r=>{r.uniforms={...r.uniforms,...this.uniforms},t?r.defines.USE_SAMPLER="":r.defines.USE_TRANSMISSION="",r.fragmentShader="\n      uniform float chromaticAberration;         \n      uniform float anisotropy;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      float seed = 0.0;\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n      float rand() {\n        float result = random(vec3(gl_FragCoord.xy, seed));\n        seed += 1.0;\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\n"+r.fragmentShader,r.fragmentShader=r.fragmentShader.replace("#include <transmission_pars_fragment>","\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\n"),r.fragmentShader=r.fragmentShader.replace("#include <transmission_fragment>",`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand();\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropy);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${e}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${e}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n`)},Object.keys(this.uniforms).forEach((e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})))}}const nr=P.forwardRef((({buffer:e,transmissionSampler:t=!1,backside:r=!1,side:n=D.FrontSide,transmission:a=1,thickness:i=0,backsideThickness:s=0,samples:l=10,resolution:c,backsideResolution:u,background:d,...m},f)=>{o.extend({MeshTransmissionMaterial:rr});const p=P.useRef(null),[h]=P.useState((()=>new tr)),v=He(u||c),g=He(c);let x,y,w;return o.useFrame((e=>{p.current.time=e.clock.getElapsedTime(),p.current.buffer!==g.texture||t||(w=p.current.__r3f.parent,w&&(y=e.gl.toneMapping,x=e.scene.background,e.gl.toneMapping=D.NoToneMapping,d&&(e.scene.background=d),w.material=h,r&&(e.gl.setRenderTarget(v),e.gl.render(e.scene,e.camera),w.material=p.current,w.material.buffer=v.texture,w.material.thickness=s,w.material.side=D.BackSide),e.gl.setRenderTarget(g),e.gl.render(e.scene,e.camera),w.material.thickness=i,w.material.side=n,w.material.buffer=g.texture,e.scene.background=x,e.gl.setRenderTarget(null),w.material=p.current,e.gl.toneMapping=y))})),P.useImperativeHandle(f,(()=>p.current),[]),P.createElement("meshTransmissionMaterial",T.default({args:[l,t],ref:p},m,{buffer:e||g.texture,_transmission:a,transmission:t?a:0,thickness:i,side:n}))})),or=P.forwardRef(((e,t)=>(o.extend({DiscardMaterialImpl:tr}),P.createElement("discardMaterialImpl",T.default({ref:t},e)))));class ar extends D.PointsMaterial{constructor(e){super(e),this.onBeforeCompile=(e,t)=>{const{isWebGL2:r}=t.capabilities;e.fragmentShader=e.fragmentShader.replace("#include <output_fragment>",`\n        ${r?"#include <output_fragment>":"#extension GL_OES_standard_derivatives : enable\n#include <output_fragment>"}\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      float r = dot(cxy, cxy);\n      float delta = fwidth(r);     \n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\n      #include <tonemapping_fragment>\n      #include <encodings_fragment>\n      `)}}}const ir=P.forwardRef(((e,t)=>{const[r]=P.useState((()=>new ar(null)));return P.createElement("primitive",T.default({},e,{object:r,ref:t,attach:"material"}))}));function sr(e,t,r){t.traverse((t=>{t.material&&(e.properties.remove(t.material),null==t.material.dispose||t.material.dispose())})),e.info.programs.length=0,e.compile(t,r)}function lr(e,t){const r=e+"Geometry";return P.forwardRef((({args:e,children:n,...o},a)=>{const i=P.useRef(null);return P.useImperativeHandle(a,(()=>i.current)),P.useLayoutEffect((()=>{null==t||t(i.current)})),P.createElement("mesh",T.default({ref:i},o),P.createElement(r,{attach:"geometry",args:e}),n)}))}const cr=lr("box"),ur=lr("circle"),dr=lr("cone"),mr=lr("cylinder"),fr=lr("sphere"),pr=lr("plane"),hr=lr("tube"),vr=lr("torus"),gr=lr("torusKnot"),xr=lr("tetrahedron"),yr=lr("ring"),wr=lr("polyhedron"),br=lr("icosahedron"),Mr=lr("octahedron"),Er=lr("dodecahedron"),Sr=lr("extrude"),Cr=lr("lathe"),Tr=lr("capsule"),Pr=lr("shape",(({geometry:e})=>{const t=e.attributes.position,r=(new D.Box3).setFromBufferAttribute(t),n=new D.Vector3;r.getSize(n);const o=[];let a=0,i=0,s=0,l=0;for(let e=0;e<t.count;e++)a=t.getX(e),i=t.getY(e),s=(a-r.min.x)/n.x,l=(i-r.min.y)/n.y,o.push(s,l);e.setAttribute("uv",new D.Float32BufferAttribute(o,2))})),Rr=1e-5;const Dr=P.forwardRef((function({args:[e=1,t=1,r=1]=[],radius:o=.05,steps:a=1,smoothness:i=4,creaseAngle:s=.4,children:l,...c},u){const m=P.useMemo((()=>function(e,t,r){const o=new n.Shape,a=r-Rr;return o.absarc(Rr,Rr,Rr,-Math.PI/2,-Math.PI,!0),o.absarc(Rr,t-2*a,Rr,Math.PI,Math.PI/2,!0),o.absarc(e-2*a,t-2*a,Rr,Math.PI/2,0,!0),o.absarc(e-2*a,Rr,Rr,0,-Math.PI/2,!0),o}(e,t,o)),[e,t,o]),f=P.useMemo((()=>({depth:r-2*o,bevelEnabled:!0,bevelSegments:2*i,steps:a,bevelSize:o-Rr,bevelThickness:o,curveSegments:i})),[r,o,i]),p=P.useRef();return P.useLayoutEffect((()=>{p.current&&(p.current.center(),d.toCreasedNormals(p.current,s))}),[m,f]),P.createElement("mesh",T.default({ref:u},c),P.createElement("extrudeGeometry",{ref:p,args:[m,f]}),l)}));function kr(){const e=new D.BufferGeometry,t=new Float32Array([-1,-1,3,-1,-1,3]);return e.setAttribute("position",new D.BufferAttribute(t,2)),e}const zr=P.forwardRef((function({children:e,...t},r){const n=P.useMemo(kr,[]);return P.createElement("mesh",T.default({ref:r,geometry:n,frustumCulled:!1},t),e)})),_r=P.forwardRef((function({children:e,disable:t,disableX:r,disableY:o,disableZ:a,left:i,right:s,top:l,bottom:c,front:u,back:d,onCentered:m,precise:f=!0,...p},h){const v=P.useRef(null),g=P.useRef(null),x=P.useRef(null);return P.useLayoutEffect((()=>{g.current.matrixWorld.identity();const e=(new n.Box3).setFromObject(x.current,f),p=new n.Vector3,h=new n.Sphere,y=e.max.x-e.min.x,w=e.max.y-e.min.y,b=e.max.z-e.min.z;e.getCenter(p),e.getBoundingSphere(h);const M=l?w/2:c?-w/2:0,E=i?-y/2:s?y/2:0,S=u?b/2:d?-b/2:0;g.current.position.set(t||r?0:-p.x+E,t||o?0:-p.y+M,t||a?0:-p.z+S),void 0!==m&&m({parent:v.current.parent,container:v.current,width:y,height:w,depth:b,boundingBox:e,boundingSphere:h,center:p,verticalAlignment:M,horizontalAlignment:E,depthAlignment:S})})),P.useImperativeHandle(h,(()=>v.current),[]),P.createElement("group",T.default({ref:v},p),P.createElement("group",{ref:g},P.createElement("group",{ref:x},e)))})),Fr=e=>e&&e.isOrthographicCamera,Lr=P.createContext(null);function Br({children:e,damping:t=6,fit:r,clip:n,observe:a,margin:i=1.2,eps:s=.01,onFit:l}){const c=P.useRef(null),{camera:u,invalidate:d,size:m,controls:f}=o.useThree(),p=f,h=P.useRef(l);function v(e,t){return Math.abs(e.x-t.x)<s&&Math.abs(e.y-t.y)<s&&Math.abs(e.z-t.z)<s}function g(e,t,r,n){e.x=D.MathUtils.damp(e.x,t.x,r,n),e.y=D.MathUtils.damp(e.y,t.y,r,n),e.z=D.MathUtils.damp(e.z,t.z,r,n)}h.current=l;const[x]=P.useState((()=>({animating:!1,focus:new D.Vector3,camera:new D.Vector3,zoom:1}))),[y]=P.useState((()=>({focus:new D.Vector3,camera:new D.Vector3,zoom:1}))),[w]=P.useState((()=>new D.Box3)),b=P.useMemo((()=>{function e(){const e=w.getSize(new D.Vector3),t=w.getCenter(new D.Vector3),r=Math.max(e.x,e.y,e.z),n=Fr(u)?4*r:r/(2*Math.atan(Math.PI*u.fov/360)),o=Fr(u)?4*r:n/u.aspect,a=i*Math.max(n,o);return{box:w,size:e,center:t,distance:a}}return{getSize:e,refresh(t){if((r=t)&&r.isBox3)w.copy(t);else{const e=t||c.current;e.updateWorldMatrix(!0,!0),w.setFromObject(e)}var r;if(w.isEmpty()){const e=u.position.length()||10;w.setFromCenterAndSize(new D.Vector3,new D.Vector3(e,e,e))}if("OrthographicTrackballControls"===(null==p?void 0:p.constructor.name)){const{distance:t}=e(),r=u.position.clone().sub(p.target).normalize().multiplyScalar(t),n=p.target.clone().add(r);u.position.copy(n)}return this},clip(){const{distance:t}=e();return p&&(p.maxDistance=10*t),u.near=t/100,u.far=100*t,u.updateProjectionMatrix(),p&&p.update(),d(),this},to({position:r,target:n}){x.camera.copy(u.position);const{center:o}=e();return y.camera.set(...r),n?y.focus.set(...n):y.focus.copy(o),t?x.animating=!0:u.position.set(...r),this},fit(){x.camera.copy(u.position),p&&x.focus.copy(p.target);const{center:r,distance:n}=e(),o=r.clone().sub(u.position).normalize().multiplyScalar(n);if(y.camera.copy(r).sub(o),y.focus.copy(r),Fr(u)){x.zoom=u.zoom;let e=0,n=0;const o=[new D.Vector3(w.min.x,w.min.y,w.min.z),new D.Vector3(w.min.x,w.max.y,w.min.z),new D.Vector3(w.min.x,w.min.y,w.max.z),new D.Vector3(w.min.x,w.max.y,w.max.z),new D.Vector3(w.max.x,w.max.y,w.max.z),new D.Vector3(w.max.x,w.max.y,w.min.z),new D.Vector3(w.max.x,w.min.y,w.max.z),new D.Vector3(w.max.x,w.min.y,w.min.z)];r.applyMatrix4(u.matrixWorldInverse);for(const t of o)t.applyMatrix4(u.matrixWorldInverse),e=Math.max(e,Math.abs(t.y-r.y)),n=Math.max(n,Math.abs(t.x-r.x));e*=2,n*=2;const a=(u.top-u.bottom)/e,s=(u.right-u.left)/n;y.zoom=Math.min(a,s)/i,t||(u.zoom=y.zoom,u.updateProjectionMatrix())}return t?x.animating=!0:(u.position.copy(y.camera),u.lookAt(y.focus),p&&(p.target.copy(y.focus),p.update())),h.current&&h.current(this.getSize()),d(),this}}}),[w,u,p,i,t,d]);P.useLayoutEffect((()=>{if(p){const e=()=>x.animating=!1;return p.addEventListener("start",e),()=>p.removeEventListener("start",e)}}),[p]);const M=P.useRef(0);return P.useLayoutEffect((()=>{(a||0==M.current++)&&(b.refresh(),r&&b.fit(),n&&b.clip())}),[m,n,r,a,u,p]),o.useFrame(((e,r)=>{if(x.animating){if(g(x.focus,y.focus,t,r),g(x.camera,y.camera,t,r),x.zoom=D.MathUtils.damp(x.zoom,y.zoom,t,r),u.position.copy(x.camera),Fr(u)&&(u.zoom=x.zoom,u.updateProjectionMatrix()),p?(p.target.copy(x.focus),p.update()):u.lookAt(x.focus),d(),Fr(u)&&!(Math.abs(x.zoom-y.zoom)<s))return;if(!Fr(u)&&!v(x.camera,y.camera))return;if(p&&!v(x.focus,y.focus))return;x.animating=!1}})),P.createElement("group",{ref:c},P.createElement(Lr.Provider,{value:b},e))}function Ar(){return P.useContext(Lr)}const Ir=P.forwardRef((({intensity:e=1,decay:t,decayRate:r=.65,maxYaw:n=.1,maxPitch:a=.1,maxRoll:i=.1,yawFrequency:s=.1,pitchFrequency:l=.1,rollFrequency:c=.1},u)=>{const m=o.useThree((e=>e.camera)),f=o.useThree((e=>e.controls)),p=P.useRef(e),h=P.useRef(m.rotation.clone()),[v]=P.useState((()=>new d.SimplexNoise)),[g]=P.useState((()=>new d.SimplexNoise)),[x]=P.useState((()=>new d.SimplexNoise)),y=()=>{(p.current<0||p.current>1)&&(p.current=p.current<0?0:1)};return P.useImperativeHandle(u,(()=>({getIntensity:()=>p.current,setIntensity:e=>{p.current=e,y()}})),[]),P.useEffect((()=>{if(f){const e=()=>{h.current=m.rotation.clone()};return f.addEventListener("change",e),e(),()=>{f.removeEventListener("change",e)}}}),[m,f]),o.useFrame(((e,o)=>{const u=Math.pow(p.current,2),d=n*u*v.noise(e.clock.elapsedTime*s,1),f=a*u*g.noise(e.clock.elapsedTime*l,1),w=i*u*x.noise(e.clock.elapsedTime*c,1);m.rotation.set(h.current.x+f,h.current.y+d,h.current.z+w),t&&p.current>0&&(p.current-=r*o,y())})),null})),Ur=P.forwardRef((({children:e,speed:t=1,rotationIntensity:r=1,floatIntensity:n=1,floatingRange:a=[-.1,.1],...i},s)=>{const l=P.useRef(null),c=P.useRef(1e4*Math.random());return o.useFrame((e=>{var o,i;const s=c.current+e.clock.getElapsedTime();l.current.rotation.x=Math.cos(s/4*t)/8*r,l.current.rotation.y=Math.sin(s/4*t)/8*r,l.current.rotation.z=Math.sin(s/4*t)/20*r;let u=Math.sin(s/4*t)/10;u=D.MathUtils.mapLinear(u,-.1,.1,null!==(o=null==a?void 0:a[0])&&void 0!==o?o:-.1,null!==(i=null==a?void 0:a[1])&&void 0!==i?i:.1),l.current.position.y=u*n})),P.createElement("group",i,P.createElement("group",{ref:_.default([l,s])},e))})),Or={sunset:"venice/venice_sunset_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",night:"dikhololo/dikhololo_night_1k.hdr",warehouse:"empty-wharehouse/empty_warehouse_01_1k.hdr",forest:"forrest-slope/forest_slope_1k.hdr",apartment:"lebombo/lebombo_1k.hdr",studio:"studio-small-3/studio_small_03_1k.hdr",city:"potsdamer-platz/potsdamer_platz_1k.hdr",park:"rooitou/rooitou_park_1k.hdr",lobby:"st-fagans/st_fagans_interior_1k.hdr"};function Vr({files:e=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"],path:t="",preset:r,encoding:a,extensions:i}={}){if(r){if(!(r in Or))throw new Error("Preset must be one of: "+Object.keys(Or).join(", "));e=Or[r],t="https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/"}const s=Array.isArray(e),l=s?n.CubeTextureLoader:d.RGBELoader,c=o.useLoader(l,s?[e]:e,(e=>{e.setPath(t),i&&i(e)})),u=s?c[0]:c;return u.mapping=s?n.CubeReflectionMapping:n.EquirectangularReflectionMapping,u.encoding=(null!=a?a:s)?n.sRGBEncoding:n.LinearEncoding,u}function jr(e,t,r,n,o=0){const a=(e=>{return(t=e).current&&t.current.isScene?e.current:e;var t})(t||r),i=a.background,s=a.environment,l=a.backgroundBlurriness||0;return"only"!==e&&(a.environment=n),e&&(a.background=n),e&&void 0!==a.backgroundBlurriness&&(a.backgroundBlurriness=o),()=>{"only"!==e&&(a.environment=s),e&&(a.background=i),e&&void 0!==a.backgroundBlurriness&&(a.backgroundBlurriness=l)}}function Wr({scene:e,background:t=!1,blur:r,map:n}){const a=o.useThree((e=>e.scene));return P.useLayoutEffect((()=>{if(n)return jr(t,e,a,n,r)}),[a,e,n,t,r]),null}function Nr({background:e=!1,scene:t,blur:r,...n}){const a=Vr(n),i=o.useThree((e=>e.scene));return P.useLayoutEffect((()=>jr(e,t,i,a,r)),[a,e,t,i,r]),null}function Gr({children:e,near:t=1,far:r=1e3,resolution:a=256,frames:i=1,map:s,background:l=!1,blur:c,scene:u,files:d,path:m,preset:f,extensions:p}){const h=o.useThree((e=>e.gl)),v=o.useThree((e=>e.scene)),g=P.useRef(null),[x]=P.useState((()=>new n.Scene)),y=P.useMemo((()=>{const e=new n.WebGLCubeRenderTarget(a);return e.texture.type=n.HalfFloatType,e}),[a]);P.useLayoutEffect((()=>(1===i&&g.current.update(h,x),jr(l,u,v,y.texture,c))),[e,x,y.texture,u,v,l,i,h]);let w=1;return o.useFrame((()=>{(i===1/0||w<i)&&(g.current.update(h,x),w++)})),P.createElement(P.Fragment,null,o.createPortal(P.createElement(P.Fragment,null,e,P.createElement("cubeCamera",{ref:g,args:[t,r,y]}),d||f?P.createElement(Nr,{background:!0,files:d,preset:f,path:m,extensions:p}):s?P.createElement(Wr,{background:!0,map:s,extensions:p}):null),x))}function Hr(e){var t,r,n,a;const i=Vr(e),s=e.map||i;P.useMemo((()=>o.extend({GroundProjectedEnvImpl:d.GroundProjectedEnv})),[]);const l=P.useMemo((()=>[s]),[s]),c=null==(t=e.ground)?void 0:t.height,u=null==(r=e.ground)?void 0:r.radius,m=null!==(n=null==(a=e.ground)?void 0:a.scale)&&void 0!==n?n:1e3;return P.createElement(P.Fragment,null,P.createElement(Wr,T.default({},e,{map:s})),P.createElement("groundProjectedEnvImpl",{args:l,scale:m,height:c,radius:u}))}function $r(e){return e.ground?P.createElement(Hr,e):e.map?P.createElement(Wr,e):e.children?P.createElement(Gr,e):P.createElement(Nr,e)}const qr=P.forwardRef((({scale:e=10,frames:t=1/0,opacity:r=1,width:n=1,height:a=1,blur:i=1,far:s=10,resolution:l=512,smooth:c=!0,color:u="#000000",depthWrite:m=!1,renderOrder:f,...p},h)=>{const v=P.useRef(null),g=o.useThree((e=>e.scene)),x=o.useThree((e=>e.gl)),y=P.useRef(null);n*=Array.isArray(e)?e[0]:e||1,a*=Array.isArray(e)?e[1]:e||1;const[w,b,M,E,S,C,R]=P.useMemo((()=>{const e=new D.WebGLRenderTarget(l,l),t=new D.WebGLRenderTarget(l,l);t.texture.generateMipmaps=e.texture.generateMipmaps=!1;const r=new D.PlaneGeometry(n,a).rotateX(Math.PI/2),o=new D.Mesh(r),i=new D.MeshDepthMaterial;i.depthTest=i.depthWrite=!1,i.onBeforeCompile=e=>{e.uniforms={...e.uniforms,ucolor:{value:new D.Color(u)}},e.fragmentShader=e.fragmentShader.replace("void main() {","uniform vec3 ucolor;\n           void main() {\n          "),e.fragmentShader=e.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );")};const s=new D.ShaderMaterial(d.HorizontalBlurShader),c=new D.ShaderMaterial(d.VerticalBlurShader);return c.depthTest=s.depthTest=!1,[e,r,i,o,s,c,t]}),[l,n,a,e,u]),k=e=>{E.visible=!0,E.material=S,S.uniforms.tDiffuse.value=w.texture,S.uniforms.h.value=1*e/256,x.setRenderTarget(R),x.render(E,y.current),E.material=C,C.uniforms.tDiffuse.value=R.texture,C.uniforms.v.value=1*e/256,x.setRenderTarget(w),x.render(E,y.current),E.visible=!1};let z,_,F=0;return o.useFrame((()=>{y.current&&(t===1/0||F<t)&&(F++,z=g.background,_=g.overrideMaterial,v.current.visible=!1,g.background=null,g.overrideMaterial=M,x.setRenderTarget(w),x.render(g,y.current),k(i),c&&k(.4*i),x.setRenderTarget(null),v.current.visible=!0,g.overrideMaterial=_,g.background=z)})),P.useImperativeHandle(h,(()=>v.current),[]),P.createElement("group",T.default({"rotation-x":Math.PI/2},p,{ref:v}),P.createElement("mesh",{renderOrder:f,geometry:b,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},P.createElement("meshBasicMaterial",{transparent:!0,map:w.texture,"map-encoding":x.outputEncoding,opacity:r,depthWrite:m})),P.createElement("orthographicCamera",{ref:y,args:[-n/2,n/2,a/2,-a/2,0,s]}))}));const Xr=P.createContext(null),Yr=ye({color:new D.Color,blend:2,alphaTest:.75,opacity:0,map:null},"varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }","varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }"),Zr=P.forwardRef((({children:e,temporal:t,frames:r=40,limit:n=1/0,blend:a=20,scale:i=10,opacity:s=1,alphaTest:l=.75,color:c="black",colorBlend:u=2,resolution:d=1024,toneMapped:m=!0,...f},p)=>{o.extend({SoftShadowMaterial:Yr});const h=o.useThree((e=>e.gl)),v=o.useThree((e=>e.scene)),g=o.useThree((e=>e.camera)),x=o.useThree((e=>e.invalidate)),y=P.useRef(null),w=P.useRef(null),[b]=P.useState((()=>new Qr(h,v,d)));P.useLayoutEffect((()=>{b.configure(y.current)}),[]);const M=P.useMemo((()=>({lights:new Map,temporal:!!t,frames:Math.max(2,r),blend:Math.max(2,r===1/0?a:r),count:0,getMesh:()=>y.current,reset:()=>{b.clear();const e=y.current.material;e.opacity=0,e.alphaTest=0,M.count=0},update:(e=1)=>{const t=y.current.material;M.temporal?(t.opacity=Math.min(s,t.opacity+s/M.blend),t.alphaTest=Math.min(l,t.alphaTest+l/M.blend)):(t.opacity=s,t.alphaTest=l),w.current.visible=!0,b.prepare();for(let t=0;t<e;t++)M.lights.forEach((e=>e.update())),b.update(g,M.blend);w.current.visible=!1,b.finish()}})),[b,g,v,t,r,a,s,l]);return P.useLayoutEffect((()=>{M.reset(),M.temporal||M.frames===1/0||M.update(M.blend)})),P.useImperativeHandle(p,(()=>M),[M]),o.useFrame((()=>{(M.temporal||M.frames===1/0)&&M.count<M.frames&&M.count<n&&(x(),M.update(),M.count++)})),P.createElement("group",f,P.createElement("group",{traverse:()=>null,ref:w},P.createElement(Xr.Provider,{value:M},e)),P.createElement("mesh",{receiveShadow:!0,ref:y,scale:i,rotation:[-Math.PI/2,0,0]},P.createElement("planeGeometry",null),P.createElement("softShadowMaterial",{transparent:!0,depthWrite:!1,toneMapped:m,color:c,blend:u,map:b.progressiveLightMap2.texture})))})),Kr=P.forwardRef((({castShadow:e=!0,bias:t=.001,mapSize:r=512,size:n=5,near:o=.5,far:a=500,frames:i=1,position:s=[0,0,0],radius:l=1,amount:c=8,intensity:u=1,ambient:d=.5,...m},f)=>{const p=P.useRef(null),h=new D.Vector3(...s).length(),v=P.useContext(Xr),g=P.useCallback((()=>{let e;if(p.current)for(let t=0;t<p.current.children.length;t++)if(e=p.current.children[t],Math.random()>d)e.position.set(s[0]+D.MathUtils.randFloatSpread(l),s[1]+D.MathUtils.randFloatSpread(l),s[2]+D.MathUtils.randFloatSpread(l));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*h,Math.abs(Math.cos(t)*Math.sin(r)*h),Math.sin(t)*h)}}),[l,d,h,...s]),x=P.useMemo((()=>({update:g})),[g]);return P.useImperativeHandle(f,(()=>x),[x]),P.useLayoutEffect((()=>{const e=p.current;return v&&v.lights.set(e.uuid,x),()=>{v.lights.delete(e.uuid)}}),[v,x]),P.createElement("group",T.default({ref:p},m),Array.from({length:c},((i,s)=>P.createElement("directionalLight",{key:s,castShadow:e,"shadow-bias":t,"shadow-mapSize":[r,r],intensity:u/c},P.createElement("orthographicCamera",{attach:"shadow-camera",args:[-n,n,n,-n,o,a]})))))}));class Qr{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new D.Color,this.clearAlpha=0;const n=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?D.HalfFloatType:D.FloatType;this.progressiveLightMap1=new D.WebGLRenderTarget(this.res,this.res,{type:n,encoding:e.outputEncoding}),this.progressiveLightMap2=new D.WebGLRenderTarget(this.res,this.res,{type:n,encoding:e.outputEncoding}),this.discardMat=new tr,this.targetMat=new D.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader="varying vec2 vUv;\n"+e.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader="varying vec2 vUv;\n"+e.fragmentShader.slice(0,t)+"uniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse((e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})}))}prepare(){this.lights.forEach((e=>e.object.intensity=0)),this.meshes.forEach((e=>e.object.material=this.discardMat))}finish(){this.lights.forEach((e=>e.object.intensity=e.intensity)),this.meshes.forEach((e=>e.object.material=e.material))}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,n=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,o=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(r),this.previousShadowMap.value=n.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=o}}const Jr={rembrandt:{main:[1,2,1],fill:[-2,-.5,-2]},portrait:{main:[-1,2,.5],fill:[-1,.5,-1.5]},upfront:{main:[0,2,1],fill:[-1,.5,-1.5]},soft:{main:[-2,4,4],fill:[-1,.5,-1.5]}};function en({radius:e,adjustCamera:t}){const r=Ar();return P.useEffect((()=>{t&&r.refresh().clip().fit()}),[e,t]),null}const tn=e=>0===e?0:Math.pow(2,10*e-10);const rn=P.forwardRef((({fog:e=!1,renderOrder:t,depthWrite:r=!1,colorStop:o=0,color:a="black",opacity:i=.5,...s},l)=>{const c=P.useMemo((()=>{const e=document.createElement("canvas");e.width=128,e.height=128;const t=e.getContext("2d"),r=t.createRadialGradient(e.width/2,e.height/2,0,e.width/2,e.height/2,e.width/2);return r.addColorStop(o,new n.Color(a).getStyle()),r.addColorStop(1,"rgba(0,0,0,0)"),t.fillStyle=r,t.fillRect(0,0,e.width,e.height),e}),[a,o]);return P.createElement("mesh",T.default({renderOrder:t,ref:l,"rotation-x":-Math.PI/2},s),P.createElement("planeGeometry",null),P.createElement("meshBasicMaterial",{transparent:!0,opacity:i,fog:e,depthWrite:r,side:n.DoubleSide},P.createElement("canvasTexture",{attach:"map",args:[c]})))}));function nn(e=D.FrontSide){const t={value:new D.Matrix4};return Object.assign(new D.MeshNormalMaterial({side:e}),{viewMatrix:t,onBeforeCompile:e=>{e.uniforms.viewMatrix=t,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const on=ye({causticsTexture:null,causticsTextureB:null,color:new D.Color,lightProjMatrix:new D.Matrix4,lightViewMatrix:new D.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }","varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n   }"),an=ye({cameraMatrixWorld:new D.Matrix4,cameraProjectionMatrixInv:new D.Matrix4,normalTexture:null,depthTexture:null,lightDir:new D.Vector3(0,1,0),lightPlaneNormal:new D.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new D.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),sn={depth:!0,minFilter:D.LinearFilter,magFilter:D.LinearFilter,encoding:D.LinearEncoding,type:D.UnsignedByteType},ln={minFilter:D.LinearMipmapLinearFilter,magFilter:D.LinearFilter,encoding:D.LinearEncoding,format:D.RGBAFormat,type:D.FloatType,generateMipmaps:!0},cn=P.forwardRef((({debug:e,children:t,frames:r=1,ior:n=1.1,color:a="white",causticsOnly:i=!1,backside:s=!1,backsideIOR:l=1.1,worldRadius:c=.3125,intensity:u=.05,resolution:m=2024,lightSource:f=[5,5,5],...p},h)=>{o.extend({CausticsProjectionMaterial:on});const v=P.useRef(null),g=P.useRef(null),x=P.useRef(null),y=P.useRef(null),w=o.useThree((e=>e.gl)),b=Ut(e&&g,D.CameraHelper),M=He(m,m,sn),E=He(m,m,sn),S=He(m,m,ln),C=He(m,m,ln),[R]=P.useState((()=>nn())),[k]=P.useState((()=>nn(D.BackSide))),[z]=P.useState((()=>new an)),[_]=P.useState((()=>new d.FullScreenQuad(z)));P.useLayoutEffect((()=>{v.current.updateWorldMatrix(!1,!0)}));let F=0;const L=new D.Vector3,B=new D.Frustum,A=new D.Matrix4,I=new D.Plane,U=new D.Vector3,O=new D.Vector3,V=new D.Box3,j=new D.Vector3;return o.useFrame(((t,o)=>{if(r===1/0||F++<r){var a,d;Array.isArray(f)?U.fromArray(f).normalize():U.copy(v.current.worldToLocal(f.current.getWorldPosition(L)).normalize()),O.copy(U).multiplyScalar(-1);let t=[];null==(a=x.current.parent)||a.matrixWorld.identity(),V.setFromObject(x.current,!0),t.push(new D.Vector3(V.min.x,V.min.y,V.min.z)),t.push(new D.Vector3(V.min.x,V.min.y,V.max.z)),t.push(new D.Vector3(V.min.x,V.max.y,V.min.z)),t.push(new D.Vector3(V.min.x,V.max.y,V.max.z)),t.push(new D.Vector3(V.max.x,V.min.y,V.min.z)),t.push(new D.Vector3(V.max.x,V.min.y,V.max.z)),t.push(new D.Vector3(V.max.x,V.max.y,V.min.z)),t.push(new D.Vector3(V.max.x,V.max.y,V.max.z));const r=t.map((e=>e.clone()));V.getCenter(j),t=t.map((e=>e.clone().sub(j)));const o=I.set(O,0),p=t.map((e=>o.projectPoint(e,new D.Vector3))),h=p.reduce(((e,t)=>e.add(t)),L.set(0,0,0)).divideScalar(p.length),T=p.map((e=>e.distanceTo(h))).reduce(((e,t)=>Math.max(e,t))),P=t.map((e=>e.dot(U))).reduce(((e,t)=>Math.max(e,t)));g.current.position.copy(U.clone().multiplyScalar(P).add(j)),g.current.lookAt(x.current.localToWorld(j.clone()));const F=A.lookAt(g.current.position,j,L.set(0,1,0));g.current.left=-T,g.current.right=T,g.current.top=T,g.current.bottom=-T;const W=L.set(0,T,0).applyMatrix4(F),N=(g.current.position.y+W.y)/U.y;g.current.near=.1,g.current.far=N,g.current.updateProjectionMatrix(),g.current.updateMatrixWorld();const G=r.map((e=>e.add(U.clone().multiplyScalar(-e.y/U.y)))),H=G.reduce(((e,t)=>e.add(t)),L.set(0,0,0)).divideScalar(G.length),$=2*G.map((e=>Math.hypot(e.x-H.x,e.z-H.z))).reduce(((e,t)=>Math.max(e,t)));y.current.scale.setScalar($),y.current.position.copy(H),e&&(null==(d=b.current)||d.update()),k.viewMatrix.value=R.viewMatrix.value=g.current.matrixWorldInverse;const q=B.setFromProjectionMatrix(A.multiplyMatrices(g.current.projectionMatrix,g.current.matrixWorldInverse)).planes[4];z.cameraMatrixWorld=g.current.matrixWorld,z.cameraProjectionMatrixInv=g.current.projectionMatrixInverse,z.lightDir=O,z.lightPlaneNormal=q.normal,z.lightPlaneConstant=q.constant,z.near=g.current.near,z.far=g.current.far,z.resolution=m,z.size=T,z.intensity=u,z.worldRadius=c,x.current.visible=!0,w.setRenderTarget(M),w.clear(),x.current.overrideMaterial=R,w.render(x.current,g.current),w.setRenderTarget(E),w.clear(),s&&(x.current.overrideMaterial=k,w.render(x.current,g.current)),x.current.overrideMaterial=null,z.ior=n,y.current.material.lightProjMatrix=g.current.projectionMatrix,y.current.material.lightViewMatrix=g.current.matrixWorldInverse,z.normalTexture=M.texture,z.depthTexture=M.depthTexture,w.setRenderTarget(S),w.clear(),_.render(w),z.ior=l,z.normalTexture=E.texture,z.depthTexture=E.depthTexture,w.setRenderTarget(C),w.clear(),s&&_.render(w),w.setRenderTarget(null),i&&(x.current.visible=!1)}})),P.useImperativeHandle(h,(()=>v.current),[]),P.createElement("group",T.default({ref:v},p),P.createElement("scene",{ref:x},P.createElement("orthographicCamera",{ref:g,up:[0,1,0]}),t),P.createElement("mesh",{renderOrder:2,ref:y,"rotation-x":-Math.PI/2},P.createElement("planeGeometry",null),P.createElement("causticsProjectionMaterial",{transparent:!0,color:a,causticsTexture:S.texture,causticsTextureB:C.texture,blending:D.CustomBlending,blendSrc:D.OneFactor,blendDst:D.SrcAlphaFactor,depthWrite:!1}),e&&P.createElement(Pe,null,P.createElement("lineBasicMaterial",{color:"#ffff00",toneMapped:!1}))))}));o.extend({MeshReflectorMaterial:Qt});const un=P.forwardRef((({mixBlur:e=0,mixStrength:t=.5,resolution:r=256,blur:a=[0,0],args:i=[1,1],minDepthThreshold:s=.9,maxDepthThreshold:l=1,depthScale:c=0,depthToBlurRatioBias:u=.25,mirror:d=0,children:m,debug:f=0,distortion:p=1,mixContrast:h=1,distortionMap:v,...g},x)=>{P.useEffect((()=>{console.warn("Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!")}),[]);const y=o.useThree((({gl:e})=>e)),w=o.useThree((({camera:e})=>e)),b=o.useThree((({scene:e})=>e)),M=(a=Array.isArray(a)?a:[a,a])[0]+a[1]>0,E=P.useRef(null),[S]=P.useState((()=>new n.Plane)),[C]=P.useState((()=>new n.Vector3)),[R]=P.useState((()=>new n.Vector3)),[D]=P.useState((()=>new n.Vector3)),[k]=P.useState((()=>new n.Matrix4)),[z]=P.useState((()=>new n.Vector3(0,0,-1))),[F]=P.useState((()=>new n.Vector4)),[L]=P.useState((()=>new n.Vector3)),[B]=P.useState((()=>new n.Vector3)),[A]=P.useState((()=>new n.Vector4)),[I]=P.useState((()=>new n.Matrix4)),[U]=P.useState((()=>new n.PerspectiveCamera)),O=P.useCallback((()=>{if(R.setFromMatrixPosition(E.current.matrixWorld),D.setFromMatrixPosition(w.matrixWorld),k.extractRotation(E.current.matrixWorld),C.set(0,0,1),C.applyMatrix4(k),L.subVectors(R,D),L.dot(C)>0)return;L.reflect(C).negate(),L.add(R),k.extractRotation(w.matrixWorld),z.set(0,0,-1),z.applyMatrix4(k),z.add(D),B.subVectors(R,z),B.reflect(C).negate(),B.add(R),U.position.copy(L),U.up.set(0,1,0),U.up.applyMatrix4(k),U.up.reflect(C),U.lookAt(B),U.far=w.far,U.updateMatrixWorld(),U.projectionMatrix.copy(w.projectionMatrix),I.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),I.multiply(U.projectionMatrix),I.multiply(U.matrixWorldInverse),I.multiply(E.current.matrixWorld),S.setFromNormalAndCoplanarPoint(C,R),S.applyMatrix4(U.matrixWorldInverse),F.set(S.normal.x,S.normal.y,S.normal.z,S.constant);const e=U.projectionMatrix;A.x=(Math.sign(F.x)+e.elements[8])/e.elements[0],A.y=(Math.sign(F.y)+e.elements[9])/e.elements[5],A.z=-1,A.w=(1+e.elements[10])/e.elements[14],F.multiplyScalar(2/F.dot(A)),e.elements[2]=F.x,e.elements[6]=F.y,e.elements[10]=F.z+1,e.elements[14]=F.w}),[]),[V,j,W,N]=P.useMemo((()=>{const o={minFilter:n.LinearFilter,magFilter:n.LinearFilter,encoding:y.outputEncoding},i=new n.WebGLRenderTarget(r,r,o);i.depthBuffer=!0,i.depthTexture=new n.DepthTexture(r,r),i.depthTexture.format=n.DepthFormat,i.depthTexture.type=n.UnsignedShortType;const m=new n.WebGLRenderTarget(r,r,o);return[i,m,new Kt({gl:y,resolution:r,width:a[0],height:a[1],minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u}),{mirror:d,textureMatrix:I,mixBlur:e,tDiffuse:i.texture,tDepth:i.depthTexture,tDiffuseBlur:m.texture,hasBlur:M,mixStrength:t,minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u,transparent:!0,debug:f,distortion:p,distortionMap:v,mixContrast:h,"defines-USE_BLUR":M?"":void 0,"defines-USE_DEPTH":c>0?"":void 0,"defines-USE_DISTORTION":v?"":void 0}]}),[y,a,I,r,d,M,e,t,s,l,c,u,f,p,v,h]);return o.useFrame((()=>{if(null==E||!E.current)return;E.current.visible=!1;const e=y.xr.enabled,t=y.shadowMap.autoUpdate;O(),y.xr.enabled=!1,y.shadowMap.autoUpdate=!1,y.setRenderTarget(V),y.state.buffers.depth.setMask(!0),y.autoClear||y.clear(),y.render(b,U),M&&W.render(y,V,j),y.xr.enabled=e,y.shadowMap.autoUpdate=t,E.current.visible=!0,y.setRenderTarget(null)})),P.createElement("mesh",T.default({ref:_.default([E,x])},g),P.createElement("planeGeometry",{args:i}),m?m("meshReflectorMaterial",N):P.createElement("meshReflectorMaterial",N))}));class dn extends n.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new n.Vector3(0,0,0)},lightColor:{value:new n.Color("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new n.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform vec3 spotPosition;\n      uniform float attenuation;      \n\n      void main() {\n        // compute intensity\n        vNormal = normalize( normalMatrix * normal );\n        vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );\n        vWorldPosition = worldPosition.xyz;\n        vec4 viewPosition = viewMatrix * worldPosition;\n        vViewZ = viewPosition.z;\n        float intensity\t= distance(worldPosition.xyz, spotPosition) / attenuation;\n        intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\n        vIntensity = intensity;        \n        // set gl_Position\n        gl_Position\t= projectionMatrix * viewPosition;\n\n      }",fragmentShader:"\n      #include <packing>\n\n      varying vec3 vNormal;\n      varying vec3 vWorldPosition;\n      uniform vec3 lightColor;\n      uniform vec3 spotPosition;\n      uniform float attenuation;\n      uniform float anglePower;\n      uniform sampler2D depth;\n      uniform vec2 resolution;\n      uniform float cameraNear;\n      uniform float cameraFar;\n      varying float vViewZ;\n      varying float vIntensity;\n      uniform float opacity;\n\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\n        float fragCoordZ = texture2D( depthSampler, coord ).x;\n        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n        return viewZ;\n      }\n\n      void main() {\n        float d = 1.0;\n        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n        if (isSoft) {\n          vec2 sUv = gl_FragCoord.xy / resolution;\n          d = readDepth(depth, sUv);\n        }\n        float intensity = vIntensity;\n        vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n        float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\n        intensity\t*= angleIntensity;\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n        if (isSoft) {\n          intensity\t*= smoothstep(0., 1., vViewZ - d);\n        }\n        gl_FragColor = vec4(lightColor, intensity * opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <encodings_fragment>\n      }"})}}function mn({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:a,color:i="white",distance:s=5,angle:l=.15,attenuation:c=5,anglePower:u=5}){const d=P.useRef(null),m=o.useThree((e=>e.size)),f=o.useThree((e=>e.camera)),p=o.useThree((e=>e.viewport.dpr)),[h]=P.useState((()=>new dn)),[v]=P.useState((()=>new n.Vector3));t=void 0===t?.1:t,r=void 0===r?7*l:r,o.useFrame((()=>{h.uniforms.spotPosition.value.copy(d.current.getWorldPosition(v)),d.current.lookAt(d.current.parent.target.getWorldPosition(v))}));const g=P.useMemo((()=>{const e=new n.CylinderGeometry(t,r,s,128,64,!0);return e.applyMatrix4((new n.Matrix4).makeTranslation(0,-s/2,0)),e.applyMatrix4((new n.Matrix4).makeRotationX(-Math.PI/2)),e}),[s,t,r]);return P.createElement(P.Fragment,null,P.createElement("mesh",{ref:d,geometry:g,raycast:()=>null},P.createElement("primitive",{object:h,attach:"material","uniforms-opacity-value":e,"uniforms-lightColor-value":i,"uniforms-attenuation-value":c,"uniforms-anglePower-value":u,"uniforms-depth-value":a,"uniforms-cameraNear-value":f.near,"uniforms-cameraFar-value":f.far,"uniforms-resolution-value":a?[m.width*p,m.height*p]:[0,0]})))}function fn(e,t,r,a,i){const[[s,l]]=P.useState((()=>[new n.Vector3,new n.Vector3]));P.useLayoutEffect((()=>{if(!(null==(t=e.current)?void 0:t.isSpotLight))throw new Error("SpotlightShadow must be a child of a SpotLight");var t;e.current.shadow.mapSize.set(r,a),e.current.shadow.needsUpdate=!0}),[e,r,a]),o.useFrame((()=>{if(!e.current)return;const r=e.current.position,n=e.current.target.position;l.copy(n).sub(r);var o=l.length();l.normalize().multiplyScalar(o*i),s.copy(r).add(l),t.current.position.copy(s),t.current.lookAt(e.current.target.position)}))}function pn({distance:e=.4,alphaTest:t=.5,map:r,shader:a="#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D uShadowMap;uniform float uTime;void main(){vec3 color=texture2D(uShadowMap,vUv).xyz;gl_FragColor=vec4(color,1.);}",width:i=512,height:s=512,scale:l=1,children:c,...u}){const m=P.useRef(null),f=u.spotlightRef,p=u.debug;fn(f,m,i,s,e);const h=P.useMemo((()=>new n.WebGLRenderTarget(i,s,{format:n.RGBAFormat,encoding:n.LinearEncoding,stencilBuffer:!1})),[i,s]),v=P.useRef({uShadowMap:{value:r},uTime:{value:0}});P.useEffect((()=>{v.current.uShadowMap.value=r}),[r]);const g=P.useMemo((()=>new d.FullScreenQuad(new n.ShaderMaterial({uniforms:v.current,vertexShader:"\n          varying vec2 vUv;\n\n          void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          }\n          ",fragmentShader:a}))),[a]);return P.useEffect((()=>()=>{g.material.dispose(),g.dispose()}),[g]),P.useEffect((()=>()=>h.dispose()),[h]),o.useFrame((({gl:e},t)=>{v.current.uTime.value+=t,e.setRenderTarget(h),g.render(e),e.setRenderTarget(null)})),P.createElement(P.Fragment,null,P.createElement("mesh",{ref:m,scale:l,castShadow:!0},P.createElement("planeGeometry",null),P.createElement("meshBasicMaterial",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:h.texture,"alphaMap-wrapS":n.RepeatWrapping,"alphaMap-wrapT":n.RepeatWrapping,opacity:p?1:0},c)))}function hn({distance:e=.4,alphaTest:t=.5,map:r,width:o=512,height:a=512,scale:i,children:s,...l}){const c=P.useRef(null),u=l.spotlightRef,d=l.debug;return fn(u,c,o,a,e),P.createElement(P.Fragment,null,P.createElement("mesh",{ref:c,scale:i,castShadow:!0},P.createElement("planeGeometry",null),P.createElement("meshBasicMaterial",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:r,"alphaMap-wrapS":n.RepeatWrapping,"alphaMap-wrapT":n.RepeatWrapping,opacity:d?1:0},s)))}const vn=P.forwardRef((({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:n,color:o="white",distance:a=5,angle:i=.15,attenuation:s=5,anglePower:l=5,volumetric:c=!0,debug:u=!1,children:d,...m},f)=>{const p=P.useRef(null);return P.createElement("group",null,u&&p.current&&P.createElement("spotLightHelper",{args:[p.current]}),P.createElement("spotLight",T.default({ref:_.default([f,p]),angle:i,color:o,distance:a,castShadow:!0},m),c&&P.createElement(mn,{debug:u,opacity:e,radiusTop:t,radiusBottom:r,depthBuffer:n,color:o,distance:a,angle:i,attenuation:s,anglePower:l})),d&&P.cloneElement(d,{spotlightRef:p,debug:u}))})),gn=P.forwardRef((({args:e,map:t,toneMapped:r=!1,color:n="white",form:a="rect",intensity:i=1,scale:s=1,target:l,children:c,...u},d)=>{const m=P.useRef(null);return P.useLayoutEffect((()=>{c||u.material||(o.applyProps(m.current.material,{color:n}),m.current.material.color.multiplyScalar(i))}),[n,i,c,u.material]),P.useLayoutEffect((()=>{l&&m.current.lookAt(Array.isArray(l)?new D.Vector3(...l):l)}),[l]),s=Array.isArray(s)&&2===s.length?[s[0],s[1],1]:s,P.createElement("mesh",T.default({ref:_.default([m,d]),scale:s},u),"circle"===a?P.createElement("ringGeometry",{args:[0,1,64]}):"ring"===a?P.createElement("ringGeometry",{args:[.5,1,64]}):"rect"===a?P.createElement("planeGeometry",null):P.createElement(a,{args:e}),c||(u.material?null:P.createElement("meshBasicMaterial",{toneMapped:r,map:t,side:D.DoubleSide})))}));function xn(e,t,r=new n.Vector3){const o=Math.PI*(e-.5),a=2*Math.PI*(t-.5);return r.x=Math.cos(a),r.y=Math.sin(o),r.z=Math.sin(a),r}const yn=P.forwardRef((({inclination:e=.6,azimuth:t=.1,distance:r=1e3,mieCoefficient:o=.005,mieDirectionalG:a=.8,rayleigh:i=.5,turbidity:s=10,sunPosition:l=xn(e,t),...c},u)=>{const m=P.useMemo((()=>(new n.Vector3).setScalar(r)),[r]),[f]=P.useState((()=>new d.Sky));return P.createElement("primitive",T.default({object:f,ref:u,"material-uniforms-mieCoefficient-value":o,"material-uniforms-mieDirectionalG-value":a,"material-uniforms-rayleigh-value":i,"material-uniforms-sunPosition-value":l,"material-uniforms-turbidity-value":s,scale:m},c))}));class wn extends n.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:"\n      uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",fragmentShader:"\n      uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n\n        #include <tonemapping_fragment>\n\t      #include <encodings_fragment>\n      }"})}}const bn=e=>(new n.Vector3).setFromSpherical(new n.Spherical(e,Math.acos(1-2*Math.random()),2*Math.random()*Math.PI)),Mn=P.forwardRef((({radius:e=100,depth:t=50,count:r=5e3,saturation:a=0,factor:i=4,fade:s=!1,speed:l=1},c)=>{const u=P.useRef(),[d,m,f]=P.useMemo((()=>{const o=[],s=[],l=Array.from({length:r},(()=>(.5+.5*Math.random())*i)),c=new n.Color;let u=e+t;const d=t/r;for(let e=0;e<r;e++)u-=d*Math.random(),o.push(...bn(u).toArray()),c.setHSL(e/r,a,.9),s.push(c.r,c.g,c.b);return[new Float32Array(o),new Float32Array(s),new Float32Array(l)]}),[r,t,i,e,a]);o.useFrame((e=>u.current&&(u.current.uniforms.time.value=e.clock.getElapsedTime()*l)));const[p]=P.useState((()=>new wn));return P.createElement("points",{ref:c},P.createElement("bufferGeometry",null,P.createElement("bufferAttribute",{attach:"attributes-position",args:[d,3]}),P.createElement("bufferAttribute",{attach:"attributes-color",args:[m,3]}),P.createElement("bufferAttribute",{attach:"attributes-size",args:[f,1]})),P.createElement("primitive",{ref:u,object:p,attach:"material",blending:n.AdditiveBlending,"uniforms-fade-value":s,depthWrite:!1,transparent:!0,vertexColors:!0}))}));const En=ye({time:0,pixelRatio:1}," uniform float pixelRatio;\n    uniform float time;\n    attribute float size;  \n    attribute float speed;  \n    attribute float opacity;\n    attribute vec3 noise;\n    attribute vec3 color;\n    varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;\n      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;\n      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPostion = projectionMatrix * viewPosition;\n      gl_Position = projectionPostion;\n      gl_PointSize = size * 25. * pixelRatio;\n      gl_PointSize *= (1.0 / - viewPosition.z);\n      vColor = color;\n      vOpacity = opacity;\n    }"," varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n      float strength = 0.05 / distanceToCenter - 0.1;\n      gl_FragColor = vec4(vColor, strength * vOpacity);\n      #include <tonemapping_fragment>\n      #include <encodings_fragment>\n    }"),Sn=e=>e&&e.constructor===Float32Array,Cn=e=>e instanceof D.Vector2||e instanceof D.Vector3||e instanceof D.Vector4,Tn=e=>Array.isArray(e)?e:Cn(e)?e.toArray():[e,e,e];function Pn(e,t,r){return P.useMemo((()=>{if(void 0!==t){if(Sn(t))return t;if(t instanceof D.Color){const r=Array.from({length:3*e},(()=>(e=>[e.r,e.g,e.b])(t))).flat();return Float32Array.from(r)}if(Cn(t)||Array.isArray(t)){const r=Array.from({length:3*e},(()=>Tn(t))).flat();return Float32Array.from(r)}return Float32Array.from({length:e},(()=>t))}return Float32Array.from({length:e},r)}),[t])}const Rn=P.forwardRef((({noise:e=1,count:t=100,speed:r=1,opacity:n=1,scale:a=1,size:i,color:s,children:l,...c},u)=>{P.useMemo((()=>o.extend({SparklesImplMaterial:En})),[]);const d=P.useRef(null),m=o.useThree((e=>e.viewport.dpr)),f=P.useMemo((()=>Float32Array.from(Array.from({length:t},(()=>Tn(a).map(D.MathUtils.randFloatSpread))).flat())),[t,a]),p=Pn(t,i,Math.random),h=Pn(t,n),v=Pn(t,r),g=Pn(3*t,e),x=Pn(void 0===s?3*t:t,Sn(s)?s:new D.Color(s),(()=>1));return o.useFrame((e=>{d.current&&d.current.material&&(d.current.material.time=e.clock.elapsedTime)})),P.useImperativeHandle(u,(()=>d.current),[]),P.createElement("points",T.default({key:`particle-${t}-${JSON.stringify(a)}`},c,{ref:d}),P.createElement("bufferGeometry",null,P.createElement("bufferAttribute",{attach:"attributes-position",args:[f,3]}),P.createElement("bufferAttribute",{attach:"attributes-size",args:[p,1]}),P.createElement("bufferAttribute",{attach:"attributes-opacity",args:[h,1]}),P.createElement("bufferAttribute",{attach:"attributes-speed",args:[v,1]}),P.createElement("bufferAttribute",{attach:"attributes-color",args:[x,3]}),P.createElement("bufferAttribute",{attach:"attributes-noise",args:[g,3]})),l||P.createElement("sparklesImplMaterial",{transparent:!0,pixelRatio:m,depthWrite:!1}))}));const Dn={uniforms:{strokeOpacity:1,fillOpacity:.25,fillMix:0,thickness:.05,colorBackfaces:!1,dashInvert:!0,dash:!1,dashRepeats:4,dashLength:.5,squeeze:!1,squeezeMin:.2,squeezeMax:1,stroke:new D.Color("#ff0000"),backfaceStroke:new D.Color("#0000ff"),fill:new D.Color("#00ff00")},vertex:"\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  ",fragment:"\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  "},kn=ye(Dn.uniforms,Dn.vertex+"\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  ",Dn.fragment+"\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  ");function zn(e){return void 0!==(null==e?void 0:e.current)}function _n(e){return"WireframeGeometry"===e.type}function Fn(e){const t=null!=(r=e)&&r.current?e.current:e;var r;if(function(e){return!(null==e||!e.isBufferGeometry)}(t))return t;{if(_n(t))throw new Error("Wireframe: WireframeGeometry is not supported.");const e=t.parent;if(function(e){return!(null==e||!e.geometry)}(e)){if(_n(e.geometry))throw new Error("Wireframe: WireframeGeometry is not supported.");return e.geometry}}}function Ln(e,t){if(e.index){console.warn("Wireframe: Requires non-indexed geometry, converting to non-indexed geometry.");const t=e.toNonIndexed();e.copy(t),e.setIndex(null)}const r=function(e,t){const r=e.getAttribute("position").count,n=[];for(let e=0;e<r;e++){const r=t?1:0;e%2==0?n.push(0,0,1,0,1,0,1,0,r):n.push(0,1,0,0,0,1,1,0,r)}return new D.BufferAttribute(Float32Array.from(n),3)}(e,t);e.setAttribute("barycentric",r)}function Bn({geometry:e,simplify:t=!1,...r}){const[n,o]=P.useState(null);P.useLayoutEffect((()=>{const r=Fn(e);if(!r)throw new Error("Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry.");Ln(r,t),zn(e)&&o(r)}),[t,e]);const a=zn(e)?n:e;return P.createElement(P.Fragment,null,a&&P.createElement("mesh",{geometry:a},P.createElement("meshWireframeMaterial",T.default({attach:"material",transparent:!0,side:D.DoubleSide,polygonOffset:!0,polygonOffsetFactor:-4},r,{extensions:{derivatives:!0,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1}}))))}function An({simplify:e=!1,...t}){const r=P.useRef(null),n=P.useMemo((()=>function(){const e={};for(const t in Dn.uniforms)e[t]={value:Dn.uniforms[t]};return e}()),[Dn.uniforms]);return function(e,t){P.useEffect((()=>{var r;e.fillOpacity.value=null!==(r=t.fillOpacity)&&void 0!==r?r:e.fillOpacity.value}),[t.fillOpacity]),P.useEffect((()=>{var r;e.fillMix.value=null!==(r=t.fillMix)&&void 0!==r?r:e.fillMix.value}),[t.fillMix]),P.useEffect((()=>{var r;e.strokeOpacity.value=null!==(r=t.strokeOpacity)&&void 0!==r?r:e.strokeOpacity.value}),[t.strokeOpacity]),P.useEffect((()=>{var r;e.thickness.value=null!==(r=t.thickness)&&void 0!==r?r:e.thickness.value}),[t.thickness]),P.useEffect((()=>{e.colorBackfaces.value=!!t.colorBackfaces}),[t.colorBackfaces]),P.useEffect((()=>{e.dash.value=!!t.dash}),[t.dash]),P.useEffect((()=>{e.dashInvert.value=!!t.dashInvert}),[t.dashInvert]),P.useEffect((()=>{var r;e.dashRepeats.value=null!==(r=t.dashRepeats)&&void 0!==r?r:e.dashRepeats.value}),[t.dashRepeats]),P.useEffect((()=>{var r;e.dashLength.value=null!==(r=t.dashLength)&&void 0!==r?r:e.dashLength.value}),[t.dashLength]),P.useEffect((()=>{e.squeeze.value=!!t.squeeze}),[t.squeeze]),P.useEffect((()=>{var r;e.squeezeMin.value=null!==(r=t.squeezeMin)&&void 0!==r?r:e.squeezeMin.value}),[t.squeezeMin]),P.useEffect((()=>{var r;e.squeezeMax.value=null!==(r=t.squeezeMax)&&void 0!==r?r:e.squeezeMax.value}),[t.squeezeMax]),P.useEffect((()=>{e.stroke.value=t.stroke?new D.Color(t.stroke):e.stroke.value}),[t.stroke]),P.useEffect((()=>{e.fill.value=t.fill?new D.Color(t.fill):e.fill.value}),[t.fill]),P.useEffect((()=>{e.backfaceStroke.value=t.backfaceStroke?new D.Color(t.backfaceStroke):e.backfaceStroke.value}),[t.backfaceStroke])}(n,t),P.useLayoutEffect((()=>{const t=Fn(r);if(!t)throw new Error("Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.");const n=t.clone();return Ln(t,e),()=>{t.copy(n),n.dispose()}}),[e]),P.useLayoutEffect((()=>{const e=r.current.parent,t=e.material.clone();return function(e,t){e.onBeforeCompile=e=>{e.uniforms={...e.uniforms,...t},e.vertexShader=e.vertexShader.replace("void main() {",`\n\t\t  ${Dn.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`),e.fragmentShader=e.fragmentShader.replace("void main() {",`\n\t\t  ${Dn.fragment}\n\t\t  void main() {\n\t\t`),e.fragmentShader=e.fragmentShader.replace("#include <color_fragment>","\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t")},e.side=D.DoubleSide,e.transparent=!0}(e.material,n),()=>{e.material.dispose(),e.material=t}}),[]),P.createElement("object3D",{ref:r})}k.extend({MeshWireframeMaterial:kn});const In=new D.Matrix4,Un=new D.Ray,On=new D.Sphere,Vn=new D.Vector3;class jn extends D.Group{constructor(){super(),this.size=0,this.color=new D.Color("white"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){var r,n;const o=this.instance.current;if(!o||!o.geometry)return;const a=o.userData.instances.indexOf(this.instanceKey);if(-1===a||a>o.geometry.drawRange.count)return;const i=null!==(r=null==(n=e.params.Points)?void 0:n.threshold)&&void 0!==r?r:1;if(On.set(this.getWorldPosition(Vn),i),!1===e.ray.intersectsSphere(On))return;In.copy(o.matrixWorld).invert(),Un.copy(e.ray).applyMatrix4(In);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=Un.distanceSqToPoint(Vn);if(c<l){const r=new D.Vector3;Un.closestPointToPoint(Vn,r),r.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(r);if(n<e.near||n>e.far)return;t.push({distance:n,distanceToRay:Math.sqrt(c),point:r,index:a,face:null,object:this})}}}let Wn,Nn;const Gn=P.createContext(null),Hn=new D.Matrix4,$n=new D.Vector3,qn=P.forwardRef((({children:e,range:t,limit:r=1e3,...n},a)=>{const i=P.useRef(null),[s,l]=P.useState([]),[[c,u,d]]=P.useState((()=>[new Float32Array(3*r),Float32Array.from({length:3*r},(()=>1)),Float32Array.from({length:r},(()=>1))]));P.useEffect((()=>{i.current.geometry.attributes.position.needsUpdate=!0})),o.useFrame((()=>{for(i.current.updateMatrix(),i.current.updateMatrixWorld(),Hn.copy(i.current.matrixWorld).invert(),i.current.geometry.drawRange.count=Math.min(r,void 0!==t?t:r,s.length),Wn=0;Wn<s.length;Wn++)Nn=s[Wn].current,Nn.getWorldPosition($n).applyMatrix4(Hn),$n.toArray(c,3*Wn),i.current.geometry.attributes.position.needsUpdate=!0,Nn.matrixWorldNeedsUpdate=!0,Nn.color.toArray(u,3*Wn),i.current.geometry.attributes.color.needsUpdate=!0,d.set([Nn.size],Wn),i.current.geometry.attributes.size.needsUpdate=!0}));const m=P.useMemo((()=>({getParent:()=>i,subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return P.createElement("points",T.default({userData:{instances:s},matrixAutoUpdate:!1,ref:_.default([a,i]),raycast:()=>null},n),P.createElement("bufferGeometry",null,P.createElement("bufferAttribute",{attach:"attributes-position",count:c.length/3,array:c,itemSize:3,usage:D.DynamicDrawUsage}),P.createElement("bufferAttribute",{attach:"attributes-color",count:u.length/3,array:u,itemSize:3,usage:D.DynamicDrawUsage}),P.createElement("bufferAttribute",{attach:"attributes-size",count:d.length,array:d,itemSize:1,usage:D.DynamicDrawUsage})),P.createElement(Gn.Provider,{value:m},e))})),Xn=P.forwardRef((({children:e,...t},r)=>{P.useMemo((()=>o.extend({PositionPoint:jn})),[]);const n=P.useRef(),{subscribe:a,getParent:i}=P.useContext(Gn);return P.useLayoutEffect((()=>a(n)),[]),P.createElement("positionPoint",T.default({instance:i(),instanceKey:n,ref:_.default([r,n])},t),e)})),Yn=P.forwardRef((({children:e,positions:t,colors:r,sizes:n,stride:a=3,...i},s)=>{const l=P.useRef(null);return o.useFrame((()=>{const e=l.current.geometry.attributes;e.position.needsUpdate=!0,r&&(e.color.needsUpdate=!0),n&&(e.size.needsUpdate=!0)})),P.createElement("points",T.default({ref:_.default([s,l])},i),P.createElement("bufferGeometry",null,P.createElement("bufferAttribute",{attach:"attributes-position",count:t.length/a,array:t,itemSize:a,usage:D.DynamicDrawUsage}),r&&P.createElement("bufferAttribute",{attach:"attributes-color",count:r.length/a,array:r,itemSize:3,usage:D.DynamicDrawUsage}),n&&P.createElement("bufferAttribute",{attach:"attributes-size",count:n.length/a,array:n,itemSize:1,usage:D.DynamicDrawUsage})),e)})),Zn=P.forwardRef(((e,t)=>e.positions instanceof Float32Array?P.createElement(Yn,T.default({},e,{ref:t})):P.createElement(qn,T.default({},e,{ref:t})))),Kn=new D.Matrix4,Qn=new D.Matrix4,Jn=[],eo=new D.Mesh;class to extends D.Group{constructor(){super(),this.color=new D.Color("white"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){const r=this.instance.current;if(!r)return;if(!r.geometry||!r.material)return;eo.geometry=r.geometry;const n=r.matrixWorld,o=r.userData.instances.indexOf(this.instanceKey);if(!(-1===o||o>r.count)){r.getMatrixAt(o,Kn),Qn.multiplyMatrices(n,Kn),eo.matrixWorld=Qn,r.material instanceof D.Material?eo.material.side=r.material.side:eo.material.side=r.material[0].side,eo.raycast(e,Jn);for(let e=0,r=Jn.length;e<r;e++){const r=Jn[e];r.instanceId=o,r.object=this,t.push(r)}Jn.length=0}}}const ro=P.createContext(null),no=new D.Matrix4,oo=new D.Matrix4,ao=new D.Matrix4,io=new D.Vector3,so=new D.Quaternion,lo=new D.Vector3,co=P.forwardRef((({context:e,children:t,...r},n)=>{P.useMemo((()=>o.extend({PositionMesh:to})),[]);const a=P.useRef(),{subscribe:i,getParent:s}=P.useContext(e||ro);return P.useLayoutEffect((()=>i(a)),[]),P.createElement("positionMesh",T.default({instance:s(),instanceKey:a,ref:_.default([n,a])},r),t)})),uo=P.forwardRef((({children:e,range:t,limit:r=1e3,frames:n=1/0,...a},i)=>{const[{context:s,instance:l}]=P.useState((()=>{const e=P.createContext(null);return{context:e,instance:P.forwardRef(((t,r)=>P.createElement(co,T.default({context:e},t,{ref:r}))))}})),c=P.useRef(null),[u,d]=P.useState([]),[[m,f]]=P.useState((()=>{const e=new Float32Array(16*r);for(let t=0;t<r;t++)ao.identity().toArray(e,16*t);return[e,new Float32Array([...new Array(3*r)].map((()=>1)))]}));P.useEffect((()=>{c.current.instanceMatrix.needsUpdate=!0}));let p=0,h=0;o.useFrame((()=>{if(n===1/0||p<n){c.current.updateMatrix(),c.current.updateMatrixWorld(),no.copy(c.current.matrixWorld).invert(),h=Math.min(r,void 0!==t?t:r,u.length),c.current.count=h,c.current.instanceMatrix.updateRange.count=16*h,c.current.instanceColor.updateRange.count=3*h;for(let e=0;e<u.length;e++){const t=u[e].current;t.matrixWorld.decompose(io,so,lo),oo.compose(io,so,lo).premultiply(no),oo.toArray(m,16*e),c.current.instanceMatrix.needsUpdate=!0,t.color.toArray(f,3*e),c.current.instanceColor.needsUpdate=!0}p++}}));const v=P.useMemo((()=>({getParent:()=>c,subscribe:e=>(d((t=>[...t,e])),()=>d((t=>t.filter((t=>t.current!==e.current)))))})),[]);return P.createElement("instancedMesh",T.default({userData:{instances:u},matrixAutoUpdate:!1,ref:_.default([i,c]),args:[null,null,0],raycast:()=>null},a),P.createElement("instancedBufferAttribute",{attach:"instanceMatrix",count:m.length/16,array:m,itemSize:16,usage:D.DynamicDrawUsage}),P.createElement("instancedBufferAttribute",{attach:"instanceColor",count:f.length/3,array:f,itemSize:3,usage:D.DynamicDrawUsage}),"function"==typeof e?P.createElement(s.Provider,{value:v},e(l)):P.createElement(ro.Provider,{value:v},e))})),mo=P.forwardRef((function({meshes:e,children:t,...r},n){const o=Array.isArray(e);if(!o)for(const t of Object.keys(e))e[t].isMesh||delete e[t];return P.createElement("group",{ref:n},P.createElement(U.default,{components:(o?e:Object.values(e)).map((({geometry:e,material:t})=>P.createElement(uo,T.default({key:e.uuid,geometry:e,material:t},r))))},(r=>o?t(...r):t(Object.keys(e).filter((t=>e[t].isMesh)).reduce(((e,t,n)=>({...e,[t]:r[n]})),{})))))})),fo=P.createContext(null),po=P.forwardRef(((e,t)=>{P.useMemo((()=>o.extend({SegmentObject:ho})),[]);const{limit:r=1e3,lineWidth:n=1,children:a,...i}=e,[s,l]=P.useState([]),[c]=P.useState((()=>new d.Line2)),[u]=P.useState((()=>new d.LineMaterial)),[m]=P.useState((()=>new d.LineSegmentsGeometry)),[f]=P.useState((()=>new D.Vector2(512,512))),[p]=P.useState((()=>Array(6*r).fill(0))),[h]=P.useState((()=>Array(6*r).fill(0))),v=P.useMemo((()=>({subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return o.useFrame((()=>{for(let t=0;t<r;t++){var e;const r=null==(e=s[t])?void 0:e.current;r&&(p[6*t+0]=r.start.x,p[6*t+1]=r.start.y,p[6*t+2]=r.start.z,p[6*t+3]=r.end.x,p[6*t+4]=r.end.y,p[6*t+5]=r.end.z,h[6*t+0]=r.color.r,h[6*t+1]=r.color.g,h[6*t+2]=r.color.b,h[6*t+3]=r.color.r,h[6*t+4]=r.color.g,h[6*t+5]=r.color.b)}m.setColors(h),m.setPositions(p),c.computeLineDistances()})),P.createElement("primitive",{object:c,ref:t},P.createElement("primitive",{object:m,attach:"geometry"}),P.createElement("primitive",T.default({object:u,attach:"material",vertexColors:!0,resolution:f,linewidth:n},i)),P.createElement(fo.Provider,{value:v},a))}));class ho{constructor(){this.color=new D.Color("white"),this.start=new D.Vector3(0,0,0),this.end=new D.Vector3(0,0,0)}}const vo=e=>e instanceof D.Vector3?e:new D.Vector3(..."number"==typeof e?[e,e,e]:e),go=P.forwardRef((({color:e,start:t,end:r},n)=>{const o=P.useContext(fo);if(!o)throw"Segment must used inside Segments component.";const a=P.useRef(null);return P.useLayoutEffect((()=>o.subscribe(a)),[]),P.createElement("segmentObject",{ref:_.default([a,n]),color:e,start:vo(t),end:vo(r)})})),xo=P.forwardRef((({children:e,hysteresis:t=0,distances:r,...n},a)=>{const i=P.useRef(null);return P.useLayoutEffect((()=>{const{current:e}=i;e.levels.length=0,e.children.forEach(((n,o)=>e.levels.push({object:n,hysteresis:t,distance:r[o]})))})),o.useFrame((e=>{var t;return null==(t=i.current)?void 0:t.update(e.camera)})),P.createElement("lOD",T.default({ref:_.default([i,a])},n),e)}));const yo=new n.Matrix4,wo=new n.Ray,bo=new n.Sphere,Mo=new n.Vector3;const Eo=t.createContext(null);const So=P.forwardRef((({children:e,compute:t,width:r,height:n,samples:a=8,renderPriority:i=0,eventPriority:s=0,frames:l=1/0,stencilBuffer:c=!1,depthBuffer:u=!0,generateMipmaps:d=!1,...m},f)=>{const{size:p,viewport:h}=o.useThree(),v=He((r||p.width)*h.dpr,(n||p.height)*h.dpr,{samples:a,stencilBuffer:c,depthBuffer:u,generateMipmaps:d}),[g]=P.useState((()=>new D.Scene)),x=P.useCallback(((e,t,r)=>{var n,o;let a=null==(n=v.texture)?void 0:n.__r3f.parent;for(;a&&!(a instanceof D.Object3D);)a=a.__r3f.parent;if(!a)return!1;r.raycaster.camera||r.events.compute(e,r,null==(o=r.previousRoot)?void 0:o.getState());const[i]=r.raycaster.intersectObject(a);if(!i)return!1;const s=i.uv;if(!s)return!1;t.raycaster.setFromCamera(t.pointer.set(2*s.x-1,2*s.y-1),t.camera)}),[]);return P.useImperativeHandle(f,(()=>v.texture),[v]),P.createElement(P.Fragment,null,o.createPortal(P.createElement(Co,{renderPriority:i,frames:l,fbo:v},e),g,{events:{compute:t||x,priority:s}}),P.createElement("primitive",T.default({object:v.texture},m)))}));function Co({frames:e,renderPriority:t,children:r,fbo:n}){let a=0;return o.useFrame((t=>{(e===1/0||a<e)&&(t.gl.setRenderTarget(n),t.gl.render(t.scene,t.camera),t.gl.setRenderTarget(null),a++)}),t),P.createElement(P.Fragment,null,r)}const To=P.forwardRef((({id:e=1,colorWrite:t=!1,depthWrite:r=!1,...n},o)=>{const a=P.useRef(null),i=P.useMemo((()=>({colorWrite:t,depthWrite:r,stencilWrite:!0,stencilRef:e,stencilFunc:D.AlwaysStencilFunc,stencilFail:D.ReplaceStencilOp,stencilZFail:D.ReplaceStencilOp,stencilZPass:D.ReplaceStencilOp})),[e,t,r]);return P.useLayoutEffect((()=>{Object.assign(a.current.material,i)})),P.useImperativeHandle(o,(()=>a.current),[]),P.createElement("mesh",T.default({ref:a,renderOrder:-e},n))}));const Po=new D.Color;function Ro(e){return"top"in e}function Do({canvasSize:e,scene:t,index:r,children:n,frames:a,rect:i,track:s}){const l=o.useThree((e=>e.get)),c=o.useThree((e=>e.camera)),u=o.useThree((e=>e.scene)),d=o.useThree((e=>e.setEvents));let m=0;return o.useFrame((r=>{var o,l;(a===1/0||m<=a)&&(i.current=null==(o=s.current)?void 0:o.getBoundingClientRect(),m++);if(i.current){const{position:{left:o,bottom:a,width:s,height:d},isOffscreen:m}=function(e,t){const{right:r,top:n,left:o,bottom:a,width:i,height:s}=t,l=t.bottom<0||n>e.height||r<0||t.left>e.width;if(Ro(e)){const t=e.top+e.height-a;return{position:{width:i,height:s,left:o-e.left,top:n,bottom:t,right:r},isOffscreen:l}}return{position:{width:i,height:s,top:n,left:o,bottom:e.height-a,right:r},isOffscreen:l}}(e,i.current),f=s/d;(l=c)&&l.isOrthographicCamera?c.left===s/-2&&c.right===s/2&&c.top===d/2&&c.bottom===d/-2||(Object.assign(c,{left:s/-2,right:s/2,top:d/2,bottom:d/-2}),c.updateProjectionMatrix()):c.aspect!==f&&(c.aspect=f,c.updateProjectionMatrix()),r.gl.setViewport(o,a,s,d),r.gl.setScissor(o,a,s,d),r.gl.setScissorTest(!0),m?(r.gl.getClearColor(Po),r.gl.setClearColor(Po,r.gl.getClearAlpha()),r.gl.clear(!0,!0)):r.gl.render(n?u:t,c),r.gl.setScissorTest(!0)}}),r),P.useEffect((()=>{const e=l().events.connected;return d({connected:s.current}),()=>d({connected:e})}),[]),P.useEffect((()=>{Ro(e)||console.warn("Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. Upgrade to @react-three/fiber ^8.1.0 for support.\n See https://github.com/pmndrs/drei/issues/944")}),[]),P.createElement(P.Fragment,null,n)}const ko=P.createContext(null),zo=new D.Vector3,_o=new D.Vector3,Fo=new D.Vector3(0,1,0),Lo=new D.Matrix4,Bo=({direction:e,axis:t})=>{const{translation:r,translationLimits:n,annotations:a,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:v,userData:g}=P.useContext(ko),x=o.useThree((e=>e.controls)),y=P.useRef(null),w=P.useRef(null),b=P.useRef(null),M=P.useRef(0),[E,S]=P.useState(!1),C=P.useCallback((n=>{a&&(y.current.innerText=`${r.current[t].toFixed(2)}`,y.current.style.display="block"),n.stopPropagation();const o=(new D.Matrix4).extractRotation(w.current.matrixWorld),i=n.point.clone(),s=(new D.Vector3).setFromMatrixPosition(w.current.matrixWorld),l=e.clone().applyMatrix4(o).normalize();b.current={clickPoint:i,dir:l},M.current=r.current[t],p({component:"Arrow",axis:t,origin:s,directions:[l]}),x&&(x.enabled=!1),n.target.setPointerCapture(n.pointerId)}),[a,e,x,p,r,t]),T=P.useCallback((e=>{if(e.stopPropagation(),E||S(!0),b.current){const{clickPoint:o,dir:i}=b.current,[s,l]=(null==n?void 0:n[t])||[void 0,void 0];let c=((e,t,r,n)=>{const o=t.dot(t),a=t.dot(e)-t.dot(r),i=t.dot(n);return 0===i?-a/o:(zo.copy(n).multiplyScalar(o/i).sub(t),_o.copy(n).multiplyScalar(a/i).add(r).sub(e),-zo.dot(_o)/zo.dot(zo))})(o,i,e.ray.origin,e.ray.direction);void 0!==s&&(c=Math.max(c,s-M.current)),void 0!==l&&(c=Math.min(c,l-M.current)),r.current[t]=M.current+c,a&&(y.current.innerText=`${r.current[t].toFixed(2)}`),Lo.makeTranslation(i.x*c,i.y*c,i.z*c),h(Lo)}}),[a,h,E,r,n,t]),R=P.useCallback((e=>{a&&(y.current.style.display="none"),e.stopPropagation(),b.current=null,v(),x&&(x.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[a,x,v]),k=P.useCallback((e=>{e.stopPropagation(),S(!1)}),[]),{cylinderLength:z,coneWidth:_,coneLength:F,matrixL:L}=P.useMemo((()=>{const t=u?c/l*1.6:l/20,r=u?.2:l/5,n=u?1-r:l-r,o=(new D.Quaternion).setFromUnitVectors(Fo,e.clone().normalize());return{cylinderLength:n,coneWidth:t,coneLength:r,matrixL:(new D.Matrix4).makeRotationFromQuaternion(o)}}),[e,l,c,u]),B=E?m:d[t];return P.createElement("group",{ref:w},P.createElement("group",{matrix:L,matrixAutoUpdate:!1,onPointerDown:C,onPointerMove:T,onPointerUp:R,onPointerOut:k},a&&P.createElement(Y,{position:[0,-F,0]},P.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:i,ref:y})),P.createElement("mesh",{visible:!1,position:[0,(z+F)/2,0],userData:g},P.createElement("cylinderGeometry",{args:[1.4*_,1.4*_,z+F,8,1]})),P.createElement(ce,{transparent:!0,raycast:()=>null,depthTest:s,points:[0,0,0,0,z,0],lineWidth:c,color:B,opacity:f,polygonOffset:!0,renderOrder:1,polygonOffsetFactor:-10}),P.createElement("mesh",{raycast:()=>null,position:[0,z+F/2,0],renderOrder:500},P.createElement("coneGeometry",{args:[_,F,24,1]}),P.createElement("meshBasicMaterial",{transparent:!0,depthTest:s,color:B,opacity:f,polygonOffset:!0,polygonOffsetFactor:-10}))))},Ao=new D.Ray,Io=new D.Vector3,Uo=new D.Matrix4,Oo=({dir1:e,dir2:t,axis:r})=>{const{translation:n,translationLimits:a,annotations:i,annotationsClass:s,depthTest:l,scale:c,lineWidth:u,fixed:d,axisColors:m,hoveredColor:f,opacity:p,onDragStart:h,onDrag:v,onDragEnd:g,userData:x}=P.useContext(ko),y=o.useThree((e=>e.controls)),w=P.useRef(null),b=P.useRef(null),M=P.useRef(null),E=P.useRef(0),S=P.useRef(0),[C,T]=P.useState(!1),R=P.useCallback((e=>{i&&(w.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`,w.current.style.display="block"),e.stopPropagation();const t=e.point.clone(),o=(new D.Vector3).setFromMatrixPosition(b.current.matrixWorld),a=(new D.Vector3).setFromMatrixColumn(b.current.matrixWorld,0).normalize(),s=(new D.Vector3).setFromMatrixColumn(b.current.matrixWorld,1).normalize(),l=(new D.Vector3).setFromMatrixColumn(b.current.matrixWorld,2).normalize(),c=(new D.Plane).setFromNormalAndCoplanarPoint(l,o);M.current={clickPoint:t,e1:a,e2:s,plane:c},E.current=n.current[(r+1)%3],S.current=n.current[(r+2)%3],h({component:"Slider",axis:r,origin:o,directions:[a,s,l]}),y&&(y.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[i,y,h,r]),k=P.useCallback((e=>{if(e.stopPropagation(),C||T(!0),M.current){const{clickPoint:t,e1:o,e2:s,plane:l}=M.current,[c,u]=(null==a?void 0:a[(r+1)%3])||[void 0,void 0],[d,m]=(null==a?void 0:a[(r+2)%3])||[void 0,void 0];Ao.copy(e.ray),Ao.intersectPlane(l,Io),Ao.direction.negate(),Ao.intersectPlane(l,Io),Io.sub(t);let[f,p]=((e,t,r)=>{const n=Math.abs(e.x)>=Math.abs(e.y)&&Math.abs(e.x)>=Math.abs(e.z)?0:Math.abs(e.y)>=Math.abs(e.x)&&Math.abs(e.y)>=Math.abs(e.z)?1:2,o=[0,1,2].sort(((e,r)=>Math.abs(t.getComponent(r))-Math.abs(t.getComponent(e)))),a=n===o[0]?o[1]:o[0],i=e.getComponent(n),s=e.getComponent(a),l=t.getComponent(n),c=t.getComponent(a),u=r.getComponent(n),d=(r.getComponent(a)-u*(s/i))/(c-l*(s/i));return[(u-d*l)/i,d]})(o,s,Io);void 0!==c&&(f=Math.max(f,c-E.current)),void 0!==u&&(f=Math.min(f,u-E.current)),void 0!==d&&(p=Math.max(p,d-S.current)),void 0!==m&&(p=Math.min(p,m-S.current)),n.current[(r+1)%3]=E.current+f,n.current[(r+2)%3]=S.current+p,i&&(w.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`),Uo.makeTranslation(f*o.x+p*s.x,f*o.y+p*s.y,f*o.z+p*s.z),v(Uo)}}),[i,v,C,n,a,r]),z=P.useCallback((e=>{i&&(w.current.style.display="none"),e.stopPropagation(),M.current=null,g(),y&&(y.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[i,y,g]),_=P.useCallback((e=>{e.stopPropagation(),T(!1)}),[]),F=P.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new D.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),L=d?1/7:c/7,B=d?.225:.225*c,A=C?f:m[r],I=P.useMemo((()=>[new D.Vector3(0,0,0),new D.Vector3(0,B,0),new D.Vector3(B,B,0),new D.Vector3(B,0,0),new D.Vector3(0,0,0)]),[B]);return P.createElement("group",{ref:b,matrix:F,matrixAutoUpdate:!1},i&&P.createElement(Y,{position:[0,0,0]},P.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:s,ref:w})),P.createElement("group",{position:[1.7*L,1.7*L,0]},P.createElement("mesh",{visible:!0,onPointerDown:R,onPointerMove:k,onPointerUp:z,onPointerOut:_,scale:B,userData:x},P.createElement("planeGeometry",null),P.createElement("meshBasicMaterial",{transparent:!0,depthTest:l,color:A,polygonOffset:!0,polygonOffsetFactor:-10,side:D.DoubleSide})),P.createElement(ce,{position:[-B/2,-B/2,0],transparent:!0,depthTest:l,points:I,lineWidth:u,color:A,opacity:p,polygonOffset:!0,polygonOffsetFactor:-10,userData:x})))},Vo=new D.Vector3,jo=new D.Vector3,Wo=e=>180*e/Math.PI,No=e=>{let t=((e,t)=>{let r=Math.floor(e/t);return r=r<0?r+1:r,e-r*t})(e,2*Math.PI);return Math.abs(t)<1e-6?0:(t<0&&(t+=2*Math.PI),t)},Go=new D.Matrix4,Ho=new D.Vector3,$o=new D.Ray,qo=new D.Vector3,Xo=({dir1:e,dir2:t,axis:r})=>{const{rotationLimits:n,annotations:a,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:v,userData:g}=P.useContext(ko),x=o.useThree((e=>e.controls)),y=P.useRef(null),w=P.useRef(null),b=P.useRef(0),M=P.useRef(0),E=P.useRef(null),[S,C]=P.useState(!1),T=P.useCallback((e=>{a&&(y.current.innerText=`${Wo(M.current).toFixed(0)}`,y.current.style.display="block"),e.stopPropagation();const t=e.point.clone(),n=(new D.Vector3).setFromMatrixPosition(w.current.matrixWorld),o=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,0).normalize(),i=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,1).normalize(),s=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,2).normalize(),l=(new D.Plane).setFromNormalAndCoplanarPoint(s,n);E.current={clickPoint:t,origin:n,e1:o,e2:i,normal:s,plane:l},p({component:"Rotator",axis:r,origin:n,directions:[o,i,s]}),x&&(x.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[a,x,p,r]),R=P.useCallback((e=>{if(e.stopPropagation(),S||C(!0),E.current){const{clickPoint:t,origin:o,e1:i,e2:s,normal:l,plane:c}=E.current,[u,d]=(null==n?void 0:n[r])||[void 0,void 0];$o.copy(e.ray),$o.intersectPlane(c,qo),$o.direction.negate(),$o.intersectPlane(c,qo);let m=((e,t,r,n,o)=>{Vo.copy(e).sub(r),jo.copy(t).sub(r);const a=n.dot(n),i=o.dot(o),s=Vo.dot(n)/a,l=Vo.dot(o)/i,c=jo.dot(n)/a,u=jo.dot(o)/i,d=Math.atan2(l,s);return Math.atan2(u,c)-d})(t,qo,o,i,s),f=Wo(m);e.shiftKey&&(f=10*Math.round(f/10),m=(e=>e*Math.PI/180)(f)),void 0!==u&&void 0!==d&&d-u<2*Math.PI?(m=No(m),m=m>Math.PI?m-2*Math.PI:m,m=O.default(m,u-b.current,d-b.current),M.current=b.current+m):(M.current=No(b.current+m),M.current=M.current>Math.PI?M.current-2*Math.PI:M.current),a&&(f=Wo(M.current),y.current.innerText=`${f.toFixed(0)}`),Go.makeRotationAxis(l,m),Ho.copy(o).applyMatrix4(Go).sub(o).negate(),Go.setPosition(Ho),h(Go)}}),[a,h,S,n,r]),k=P.useCallback((e=>{a&&(y.current.style.display="none"),e.stopPropagation(),b.current=M.current,E.current=null,v(),x&&(x.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[a,x,v]),z=P.useCallback((e=>{e.stopPropagation(),C(!1)}),[]),_=P.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new D.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),F=u?.65:.65*l,L=P.useMemo((()=>{const e=[];for(let t=0;t<=32;t++){const r=t*(Math.PI/2)/32;e.push(new D.Vector3(Math.cos(r)*F,Math.sin(r)*F,0))}return e}),[F]);return P.createElement("group",{ref:w,onPointerDown:T,onPointerMove:R,onPointerUp:k,onPointerOut:z,matrix:_,matrixAutoUpdate:!1},a&&P.createElement(Y,{position:[F,F,0]},P.createElement("div",{style:{display:"none",background:"#151520",color:"white",padding:"6px 8px",borderRadius:7,whiteSpace:"nowrap"},className:i,ref:y})),P.createElement(ce,{points:L,lineWidth:4*c,visible:!1,userData:g}),P.createElement(ce,{transparent:!0,raycast:()=>null,depthTest:s,points:L,lineWidth:c,color:S?m:d[r],opacity:f,polygonOffset:!0,polygonOffsetFactor:-10}))},Yo=new D.Vector3,Zo=new D.Vector3,Ko=new D.Vector3,Qo=(e,t,r,n=1)=>{const o=Yo.set(e.x/r.width*2-1,-e.y/r.height*2+1,n);return o.unproject(t),o},Jo=(e,t,r,n)=>{const o=((e,t,r)=>{const n=r.width/2,o=r.height/2;t.updateMatrixWorld(!1);const a=e.project(t);return a.x=a.x*n+n,a.y=-a.y*o+o,a})(Ko.copy(e),r,n);let a=0;for(let i=0;i<2;++i){const s=Zo.copy(o).setComponent(i,o.getComponent(i)+t),l=Qo(s,r,n,s.z);a=Math.max(a,e.distanceTo(l))}return a},ea=new D.Matrix4,ta=new D.Matrix4,ra=new D.Matrix4,na=new D.Matrix4,oa=new D.Matrix4,aa=new D.Matrix4,ia=new D.Matrix4,sa=new D.Matrix4,la=new D.Box3,ca=new D.Box3,ua=new D.Vector3,da=new D.Vector3,ma=new D.Vector3,fa=new D.Vector3,pa=new D.Vector3(1,0,0),ha=new D.Vector3(0,1,0),va=new D.Vector3(0,0,1),ga=P.forwardRef((({matrix:e,onDragStart:t,onDrag:r,onDragEnd:n,autoTransform:a=!0,anchor:i,disableAxes:s=!1,disableSliders:l=!1,disableRotations:c=!1,activeAxes:u=[!0,!0,!0],offset:d=[0,0,0],rotation:m=[0,0,0],scale:f=1,lineWidth:p=4,fixed:h=!1,translationLimits:v,rotationLimits:g,depthTest:x=!0,axisColors:y=["#ff2060","#20df80","#2080ff"],hoveredColor:w="#ffff40",annotations:b=!1,annotationsClass:M,opacity:E=1,visible:S=!0,userData:C,children:R,...k},z)=>{const _=o.useThree((e=>e.invalidate)),F=P.useRef(null),L=P.useRef(null),B=P.useRef(null),A=P.useRef(null),I=P.useRef([0,0,0]);P.useLayoutEffect((()=>{i&&(A.current.updateWorldMatrix(!0,!0),na.copy(A.current.matrixWorld).invert(),la.makeEmpty(),A.current.traverse((e=>{e.geometry&&(e.geometry.boundingBox||e.geometry.computeBoundingBox(),aa.copy(e.matrixWorld).premultiply(na),ca.copy(e.geometry.boundingBox),ca.applyMatrix4(aa),la.union(ca))})),ua.copy(la.max).add(la.min).multiplyScalar(.5),da.copy(la.max).sub(la.min).multiplyScalar(.5),ma.copy(da).multiply(new D.Vector3(...i)).add(ua),fa.set(...d).add(ma),B.current.position.copy(fa),_())}));const U=P.useMemo((()=>({onDragStart:e=>{ea.copy(L.current.matrix),ta.copy(L.current.matrixWorld),t&&t(e),_()},onDrag:e=>{ra.copy(F.current.matrixWorld),na.copy(ra).invert(),oa.copy(ta).premultiply(e),aa.copy(oa).premultiply(na),ia.copy(ea).invert(),sa.copy(aa).multiply(ia),a&&L.current.matrix.copy(aa),r&&r(aa,sa,oa,e),_()},onDragEnd:()=>{n&&n(),_()},translation:I,translationLimits:v,rotationLimits:g,axisColors:y,hoveredColor:w,opacity:E,scale:f,lineWidth:p,fixed:h,depthTest:x,userData:C,annotations:b,annotationsClass:M})),[t,r,n,I,v,g,x,f,p,h,...y,w,E,C,a,b,M]),O=new D.Vector3;return o.useFrame((e=>{if(h){const o=Jo(B.current.getWorldPosition(O),f,e.camera,e.size);var t,r,n;if(B.current)(null==(t=B.current)?void 0:t.scale.x)===o&&(null==(r=B.current)?void 0:r.scale.y)===o&&(null==(n=B.current)?void 0:n.scale.z)===o||(B.current.scale.setScalar(o),e.invalidate())}})),P.useImperativeHandle(z,(()=>L.current),[]),P.useLayoutEffect((()=>{e&&e instanceof D.Matrix4&&(L.current.matrix=e)}),[e]),P.createElement(ko.Provider,{value:U},P.createElement("group",{ref:F},P.createElement("group",T.default({ref:L,matrix:e,matrixAutoUpdate:!1},k),P.createElement("group",{visible:S,ref:B,position:d,rotation:m},!s&&u[0]&&P.createElement(Bo,{axis:0,direction:pa}),!s&&u[1]&&P.createElement(Bo,{axis:1,direction:ha}),!s&&u[2]&&P.createElement(Bo,{axis:2,direction:va}),!l&&u[0]&&u[1]&&P.createElement(Oo,{axis:2,dir1:pa,dir2:ha}),!l&&u[0]&&u[2]&&P.createElement(Oo,{axis:1,dir1:va,dir2:pa}),!l&&u[2]&&u[1]&&P.createElement(Oo,{axis:0,dir1:ha,dir2:va}),!c&&u[0]&&u[1]&&P.createElement(Xo,{axis:2,dir1:pa,dir2:ha}),!c&&u[0]&&u[2]&&P.createElement(Xo,{axis:1,dir1:va,dir2:pa}),!c&&u[2]&&u[1]&&P.createElement(Xo,{axis:0,dir1:ha,dir2:va})),P.createElement("group",{ref:A},R))))}));exports.AccumulativeShadows=Zr,exports.AdaptiveDpr=function({pixelated:e}){const t=o.useThree((e=>e.gl)),r=o.useThree((e=>e.internal.active)),n=o.useThree((e=>e.performance.current)),a=o.useThree((e=>e.viewport.initialDpr)),i=o.useThree((e=>e.setDpr));return P.useEffect((()=>{const n=t.domElement;return()=>{r&&i(a),e&&n&&(n.style.imageRendering="auto")}}),[]),P.useEffect((()=>{i(n*a),e&&t.domElement&&(t.domElement.style.imageRendering=1===n?"auto":"pixelated")}),[n]),null},exports.AdaptiveEvents=function(){const e=o.useThree((e=>e.get)),t=o.useThree((e=>e.setEvents)),r=o.useThree((e=>e.performance.current));return P.useEffect((()=>{const r=e().events.enabled;return()=>t({enabled:r})}),[]),P.useEffect((()=>t({enabled:1===r})),[r]),null},exports.ArcballControls=et,exports.AsciiRenderer=function({renderIndex:e=1,bgColor:t="black",fgColor:r="white",characters:n=" .:-+*=%@#",invert:a=!0,color:i=!1,resolution:s=.15}){const{size:l,gl:c,scene:u,camera:m}=o.useThree(),f=P.useMemo((()=>{const e=new d.AsciiEffect(c,n,{invert:a,color:i,resolution:s});return e.domElement.style.position="absolute",e.domElement.style.top="0px",e.domElement.style.left="0px",e.domElement.style.pointerEvents="none",e}),[n,a,i,s]);P.useLayoutEffect((()=>{f.domElement.style.color=r,f.domElement.style.backgroundColor=t}),[r,t]),P.useEffect((()=>(c.domElement.style.opacity="0",c.domElement.parentNode.appendChild(f.domElement),()=>{c.domElement.style.opacity="1",c.domElement.parentNode.removeChild(f.domElement)})),[f]),P.useEffect((()=>{f.setSize(l.width,l.height)}),[f,l]),o.useFrame((e=>{f.render(u,m)}),e)},exports.BBAnchor=({anchor:e,...t})=>{const r=P.useRef(null),n=P.useRef(null);return P.useEffect((()=>{var e,t;null!=(e=r.current)&&null!=(t=e.parent)&&t.parent&&(n.current=r.current.parent,r.current.parent.parent.add(r.current))}),[]),o.useFrame((()=>{n.current&&(jt.setFromObject(n.current),jt.getSize(Wt),r.current.position.set(n.current.position.x+Wt.x*e[0]/2,n.current.position.y+Wt.y*e[1]/2,n.current.position.z+Wt.z*e[2]/2))})),P.createElement("group",T.default({ref:r},t))},exports.Backdrop=function({children:e,floor:t=.25,segments:r=20,receiveShadow:n,...o}){const a=P.useRef(null);return P.useLayoutEffect((()=>{let e=0;const n=r/r/2,o=a.current.attributes.position;for(let a=0;a<r+1;a++)for(let i=0;i<r+1;i++)o.setXYZ(e++,a/r-n+(0===a?-t:0),i/r-n,tn(a/r));o.needsUpdate=!0,a.current.computeVertexNormals()}),[r,t]),P.createElement("group",o,P.createElement("mesh",{receiveShadow:n,rotation:[-Math.PI/2,0,Math.PI/2]},P.createElement("planeGeometry",{ref:a,args:[1,1,r,r]}),e))},exports.BakeShadows=function(){const e=o.useThree((e=>e.gl));return t.useEffect((()=>(e.shadowMap.autoUpdate=!1,e.shadowMap.needsUpdate=!0,()=>{e.shadowMap.autoUpdate=e.shadowMap.needsUpdate=!0})),[e.shadowMap]),null},exports.Billboard=se,exports.Bounds=Br,exports.Box=cr,exports.Bvh=Vt,exports.CameraControls=ot,exports.CameraShake=Ir,exports.Capsule=Tr,exports.CatmullRomLine=fe,exports.Caustics=cn,exports.Center=_r,exports.Circle=ur,exports.Clone=Fe,exports.Cloud=function({opacity:e=.5,speed:t=.4,width:r=10,depth:n=1.5,segments:a=20,texture:i="https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",color:s="#ffffff",depthTest:l=!0,...c}){const u=o.useThree((e=>e.gl)),d=P.useRef(),m=be(i),f=P.useMemo((()=>[...new Array(a)].map(((e,n)=>({x:r/2-Math.random()*r,y:r/2-Math.random()*r,scale:.4+Math.sin((n+1)/a*Math.PI)*(10*(.2+Math.random())),density:Math.max(.2,Math.random()),rotation:Math.max(.002,.005*Math.random())*t})))),[r,a,t]);return o.useFrame((e=>{var t;return null==(t=d.current)?void 0:t.children.forEach(((t,r)=>{t.children[0].rotation.z+=f[r].rotation,t.children[0].scale.setScalar(f[r].scale+(1+Math.sin(e.clock.getElapsedTime()/10))/2*r/10)}))})),P.createElement("group",c,P.createElement("group",{position:[0,0,a/2*n],ref:d},f.map((({x:t,y:r,scale:o,density:a},i)=>P.createElement(se,{key:i,position:[t,r,-i*n]},P.createElement(pr,{scale:o,rotation:[0,0,0]},P.createElement("meshStandardMaterial",{map:m,"map-encoding":u.outputEncoding,transparent:!0,opacity:o/6*a*e,depthTest:l,color:s})))))))},exports.ComputedAttribute=({compute:e,name:t,...r})=>{const[o]=P.useState((()=>new n.BufferAttribute(new Float32Array(0),1))),a=P.useRef(null);return P.useLayoutEffect((()=>{if(a.current){var t;const r=null!==(t=a.current.parent)&&void 0!==t?t:a.current.__r3f.parent,n=e(r);a.current.copy(n)}}),[e]),P.createElement("primitive",T.default({ref:a,object:o,attach:`attributes-${t}`},r))},exports.Cone=dr,exports.ContactShadows=qr,exports.CubeCamera=function({children:e,frames:t=1/0,resolution:r,near:n,far:a,envMap:i,fog:s,...l}){const c=P.useRef(),{fbo:u,camera:d,update:m}=Xe({resolution:r,near:n,far:a,envMap:i,fog:s});let f=0;return o.useFrame((()=>{c.current&&(t===1/0||f<t)&&(c.current.visible=!1,m(),c.current.visible=!0,f++)})),P.createElement("group",l,P.createElement("primitive",{object:d}),P.createElement("group",{ref:c},e(u.texture)))},exports.CubicBezierLine=me,exports.CurveModifier=Ht,exports.CycleRaycast=function({onChanged:e,portal:t,preventDefault:r=!0,scroll:n=!0,keyCode:a=9}){const i=P.useRef(0),s=o.useThree((e=>e.setEvents)),l=o.useThree((e=>e.get)),c=o.useThree((e=>e.gl));return P.useEffect((()=>{var o;let u,d=[];const m=l().events.filter,f=null!==(o=null==t?void 0:t.current)&&void 0!==o?o:c.domElement.parentNode,p=()=>f&&e&&e(d,Math.round(i.current)%d.length);s({filter:(e,t)=>{let r=[...e];r.length===d.length&&d.every((e=>r.map((e=>e.object.uuid)).includes(e.object.uuid)))||(i.current=0,d=r,p()),m&&(r=m(r,t));for(let e=0;e<Math.round(i.current)%r.length;e++){const e=r.shift();r=[...r,e]}return r}});const h=e=>{var t,r;i.current=e(i.current),null==(t=l().events.handlers)||t.onPointerCancel(void 0),null==(r=l().events.handlers)||r.onPointerMove(u),p()},v=e=>{(e.keyCode||e.which===a)&&(r&&e.preventDefault(),d.length>1&&h((e=>e+1)))},g=e=>{r&&e.preventDefault();let t=0;e||(e=window.event),e.wheelDelta?t=e.wheelDelta/120:e.detail&&(t=-e.detail/3),d.length>1&&h((e=>Math.abs(e-t)))},x=e=>u=e;return document.addEventListener("pointermove",x,{passive:!0}),n&&document.addEventListener("wheel",g),void 0!==a&&document.addEventListener("keydown",v),()=>{s({filter:m}),void 0!==a&&document.removeEventListener("keydown",v),n&&document.removeEventListener("wheel",g),document.removeEventListener("pointermove",x)}}),[c,l,s,r,n,a]),null},exports.Cylinder=mr,exports.Decal=Oe,exports.Detailed=xo,exports.DeviceOrientationControls=Ye,exports.Dodecahedron=Er,exports.Edges=Pe,exports.Effects=xe,exports.Environment=$r,exports.EnvironmentCube=Nr,exports.EnvironmentMap=Wr,exports.EnvironmentPortal=Gr,exports.Extrude=Sr,exports.FirstPersonControls=nt,exports.Float=Ur,exports.FlyControls=Ze,exports.GizmoHelper=({alignment:e="bottom-right",margin:t=[80,80],renderPriority:r=1,onUpdate:a,onTarget:i,children:s})=>{const l=o.useThree((e=>e.size)),c=o.useThree((e=>e.camera)),u=o.useThree((e=>e.controls)),d=o.useThree((e=>e.invalidate)),m=P.useRef(),f=P.useRef(null),p=P.useRef(!1),h=P.useRef(0),v=P.useRef(new n.Vector3(0,0,0)),g=P.useRef(new n.Vector3(0,0,0));P.useEffect((()=>{g.current.copy(c.up)}),[c]);const x=P.useCallback((e=>{p.current=!0,(u||i)&&(v.current=(null==u?void 0:u.target)||(null==i?void 0:i())),h.current=c.position.distanceTo(pt),mt.copy(c.quaternion),ht.copy(e).multiplyScalar(h.current).add(pt),ut.lookAt(ht),ut.up.copy(c.up),ft.copy(ut.quaternion),d()}),[u,c,i,d]);o.useFrame(((e,t)=>{if(f.current&&m.current){var r;if(p.current)if(mt.angleTo(ft)<.01)p.current=!1,"minPolarAngle"in u&&c.up.copy(g.current);else{const e=t*ct;mt.rotateTowards(ft,e),c.position.set(0,0,1).applyQuaternion(mt).multiplyScalar(h.current).add(v.current),c.up.set(0,1,0).applyQuaternion(mt).normalize(),c.quaternion.copy(mt),a?a():u&&u.update(),d()}dt.copy(c.matrix).invert(),null==(r=m.current)||r.quaternion.setFromRotationMatrix(dt)}}));const y=P.useMemo((()=>({tweenCamera:x})),[x]),[w,b]=t,M=e.endsWith("-center")?0:e.endsWith("-left")?-l.width/2+w:l.width/2-w,E=e.startsWith("center-")?0:e.startsWith("top-")?l.height/2-b:-l.height/2+b;return P.createElement(it,{renderPriority:r},P.createElement(st.Provider,{value:y},P.createElement($e,{makeDefault:!0,ref:f,position:[0,0,200]}),P.createElement("group",{ref:m,position:[M,E,0]},s)))},exports.GizmoViewcube=e=>P.createElement("group",{scale:[60,60,60]},P.createElement(Pt,e),St.map(((t,r)=>P.createElement(Rt,T.default({key:r,position:t,dimensions:Ct[r]},e)))),Mt.map(((t,r)=>P.createElement(Rt,T.default({key:r,position:t,dimensions:Et},e)))),P.createElement("ambientLight",{intensity:.5}),P.createElement("pointLight",{position:[10,10,10],intensity:.5})),exports.GizmoViewport=({hideNegativeAxes:e,hideAxisHeads:t,disabled:r,font:n="18px Inter var, Arial, sans-serif",axisColors:o=["#ff2060","#20df80","#2080ff"],axisHeadScale:a=1,axisScale:i,labels:s=["X","Y","Z"],labelColor:l="#000",onClick:c,...u})=>{const[d,m,f]=o,{tweenCamera:p}=lt(),h={font:n,disabled:r,labelColor:l,onClick:c,axisHeadScale:a,onPointerDown:r?void 0:e=>{p(e.object.position),e.stopPropagation()}};return P.createElement("group",T.default({scale:40},u),P.createElement(Dt,{color:d,rotation:[0,0,0],scale:i}),P.createElement(Dt,{color:m,rotation:[0,0,Math.PI/2],scale:i}),P.createElement(Dt,{color:f,rotation:[0,-Math.PI/2,0],scale:i}),!t&&P.createElement(P.Fragment,null,P.createElement(kt,T.default({arcStyle:d,position:[1,0,0],label:s[0]},h)),P.createElement(kt,T.default({arcStyle:m,position:[0,1,0],label:s[1]},h)),P.createElement(kt,T.default({arcStyle:f,position:[0,0,1],label:s[2]},h)),!e&&P.createElement(P.Fragment,null,P.createElement(kt,T.default({arcStyle:d,position:[-1,0,0]},h)),P.createElement(kt,T.default({arcStyle:m,position:[0,-1,0]},h)),P.createElement(kt,T.default({arcStyle:f,position:[0,0,-1]},h)))),P.createElement("ambientLight",{intensity:.5}),P.createElement("pointLight",{position:[10,10,10],intensity:.5}))},exports.Gltf=Ge,exports.GradientTexture=function({stops:e,colors:t,size:r=1024,...n}){const a=o.useThree((e=>e.gl)),i=P.useMemo((()=>{const n=document.createElement("canvas"),o=n.getContext("2d");n.width=16,n.height=r;const a=o.createLinearGradient(0,0,0,r);let i=e.length;for(;i--;)a.addColorStop(e[i],t[i]);o.fillStyle=a,o.fillRect(0,0,16,r);const s=new D.Texture(n);return s.needsUpdate=!0,s}),[e]);return P.useEffect((()=>()=>{i.dispose()}),[i]),P.createElement("primitive",T.default({object:i,attach:"map",encoding:a.outputEncoding},n))},exports.Grid=_t,exports.Html=Y,exports.Hud=it,exports.Icosahedron=br,exports.Image=Te,exports.Instance=co,exports.Instances=uo,exports.IsObject=we,exports.KeyboardControls=function({map:e,children:t,onChange:r,domElement:n}){const o=e.map((e=>e.name+e.keys)).join("-"),a=P.useMemo((()=>z.default(u.subscribeWithSelector((()=>e.reduce(((e,t)=>({...e,[t.name]:!1})),{}))))),[o]),i=P.useMemo((()=>[a.subscribe,a.getState,a]),[o]),s=a.setState;return P.useEffect((()=>{const t=e.map((({name:e,keys:t,up:n})=>({keys:t,up:n,fn:t=>{s({[e]:t}),r&&r(e,t,i[1]())}}))).reduce(((e,{keys:t,fn:r,up:n=!0})=>(t.forEach((t=>e[t]={fn:r,pressed:!1,up:n})),e)),{}),o=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:o,pressed:a,up:i}=n;n.pressed=!0,!i&&a||o(!0)},a=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:o,up:a}=n;n.pressed=!1,a&&o(!1)},l=n||window;return l.addEventListener("keydown",o,{passive:!0}),l.addEventListener("keyup",a,{passive:!0}),()=>{l.removeEventListener("keydown",o),l.removeEventListener("keyup",a)}}),[n,o]),P.createElement(ae.Provider,{value:i,children:t})},exports.Lathe=Cr,exports.Lightformer=gn,exports.Line=ce,exports.Loader=function({containerStyles:e,innerStyles:t,barStyles:r,dataStyles:n,dataInterpolation:o=Q,initialState:a=(e=>e)}){const{active:i,progress:s}=K(),l=P.useRef(0),c=P.useRef(0),u=P.useRef(null),[d,m]=P.useState(a(i));P.useEffect((()=>{let e;return i!==d&&(e=setTimeout((()=>m(i)),300)),()=>clearTimeout(e)}),[d,i]);const f=P.useCallback((()=>{u.current&&(l.current+=(s-l.current)/2,(l.current>.95*s||100===s)&&(l.current=s),u.current.innerText=o(l.current),l.current<s&&(c.current=requestAnimationFrame(f)))}),[o,s]);return P.useEffect((()=>(f(),()=>cancelAnimationFrame(c.current))),[f]),d?P.createElement("div",{style:{...J.container,opacity:i?1:0,...e}},P.createElement("div",null,P.createElement("div",{style:{...J.inner,...t}},P.createElement("div",{style:{...J.bar,transform:`scaleX(${s/100})`,...r}}),P.createElement("span",{ref:u,style:{...J.data,...n}})))):null},exports.MapControls=Ke,exports.MarchingCube=Ae,exports.MarchingCubes=Be,exports.MarchingPlane=Ie,exports.Mask=To,exports.Merged=mo,exports.MeshDiscardMaterial=or,exports.MeshDistortMaterial=qt,exports.MeshReflectorMaterial=Jt,exports.MeshRefractionMaterial=function({aberrationStrength:e=0,fastChroma:r=!0,envMap:n,...a}){o.extend({MeshRefractionMaterial:er});const i=t.useRef(),{size:s}=o.useThree(),l=t.useMemo((()=>{var t,o;const a={},i=(s=n)&&s.isCubeTexture;var s;const l=(null!==(t=i?null==(o=n.image[0])?void 0:o.width:n.image.width)&&void 0!==t?t:1024)/4,c=Math.floor(Math.log2(l)),u=Math.pow(2,c),d=3*Math.max(u,112),m=4*u;return i&&(a.ENVMAP_TYPE_CUBEM=""),a.CUBEUV_TEXEL_WIDTH=""+1/d,a.CUBEUV_TEXEL_HEIGHT=""+1/m,a.CUBEUV_MAX_MIP=`${c}.0`,e>0&&(a.CHROMATIC_ABERRATIONS=""),r&&(a.FAST_CHROMA=""),a}),[e,r]);return t.useLayoutEffect((()=>{var e,t,r;const n=null==(e=i.current)||null==(t=e.__r3f)||null==(r=t.parent)?void 0:r.geometry;n&&i.current.bvh.updateFrom(new b.MeshBVH(n.toNonIndexed(),{lazyGeneration:!1,strategy:b.SAH}))}),[]),o.useFrame((({camera:e})=>{i.current.viewMatrixInverse=e.matrixWorld,i.current.projectionMatrixInverse=e.projectionMatrixInverse})),P.createElement("meshRefractionMaterial",T.default({key:JSON.stringify(l),defines:l,ref:i,resolution:[s.width,s.height],aberrationStrength:e,envMap:n},a))},exports.MeshTransmissionMaterial=nr,exports.MeshWobbleMaterial=Yt,exports.Octahedron=Mr,exports.OrbitControls=Qe,exports.OrthographicCamera=$e,exports.PerformanceMonitor=function({iterations:e=10,ms:r=250,threshold:n=.75,step:a=.1,factor:i=.5,flipflops:s=1/0,bounds:l=(e=>e>100?[60,100]:[40,60]),onIncline:c,onDecline:u,onChange:d,onFallback:m,children:f}){const p=Math.pow(10,0),[h,v]=t.useState((()=>({fps:0,index:0,factor:i,flipped:0,refreshrate:0,fallback:!1,frames:[],averages:[],subscriptions:new Map,subscribe:e=>{const t=Symbol();return h.subscriptions.set(t,e.current),()=>{h.subscriptions.delete(t)}}})));let g=0;return o.useFrame((()=>{const{frames:t,averages:o}=h;if(!h.fallback&&o.length<e){t.push(performance.now());const i=t[t.length-1]-t[0];if(i>=r){if(h.fps=Math.round(t.length/i*1e3*p)/p,h.refreshrate=Math.max(h.refreshrate,h.fps),o[h.index++%e]=h.fps,o.length===e){const[t,r]=l(h.refreshrate),i=o.filter((e=>e>=r)),f=o.filter((e=>e<t));i.length>e*n&&(h.factor=Math.min(1,h.factor+a),h.flipped++,c&&c(h),h.subscriptions.forEach((e=>e.onIncline&&e.onIncline(h)))),f.length>e*n&&(h.factor=Math.max(0,h.factor-a),h.flipped++,u&&u(h),h.subscriptions.forEach((e=>e.onDecline&&e.onDecline(h)))),g!==h.factor&&(g=h.factor,d&&d(h),h.subscriptions.forEach((e=>e.onChange&&e.onChange(h)))),h.flipped>s&&!h.fallback&&(h.fallback=!0,m&&m(h),h.subscriptions.forEach((e=>e.onFallback&&e.onFallback(h)))),h.averages=[]}h.frames=[]}}})),P.createElement(Eo.Provider,{value:h},f)},exports.PerspectiveCamera=qe,exports.PivotControls=ga,exports.Plane=pr,exports.Point=Xn,exports.PointMaterial=ir,exports.PointMaterialImpl=ar,exports.PointerLockControls=rt,exports.Points=Zn,exports.PointsBuffer=Yn,exports.Polyhedron=wr,exports.PositionPoint=jn,exports.PositionalAudio=pe,exports.Preload=function({all:e,scene:t,camera:r}){const a=o.useThree((({gl:e})=>e)),i=o.useThree((({camera:e})=>e)),s=o.useThree((({scene:e})=>e));return P.useLayoutEffect((()=>{const o=[];e&&(t||s).traverse((e=>{!1===e.visible&&(o.push(e),e.visible=!0)})),a.compile(t||s,r||i);const l=new n.WebGLCubeRenderTarget(128);new n.CubeCamera(.01,1e5,l).update(a,t||s),l.dispose(),o.forEach((e=>e.visible=!1))}),[]),null},exports.PresentationControls=function({enabled:e=!0,snap:t,global:r,domElement:a,cursor:i=!0,children:s,speed:u=1,rotation:d=[0,0,0],zoom:m=1,polar:f=[0,Math.PI/2],azimuth:p=[-1/0,1/0],config:h={mass:1,tension:170,friction:26}}){const v=o.useThree((e=>e.events)),g=o.useThree((e=>e.gl)),x=a||v.connected||g.domElement,{size:y}=o.useThree(),w=P.useMemo((()=>[d[0]+f[0],d[0]+f[1]]),[d[0],f[0],f[1]]),b=P.useMemo((()=>[d[1]+p[0],d[1]+p[1]]),[d[1],p[0],p[1]]),M=P.useMemo((()=>[n.MathUtils.clamp(d[0],...w),n.MathUtils.clamp(d[1],...b),d[2]]),[d[0],d[1],d[2],w,b]),[E,S]=l.useSpring((()=>({scale:1,rotation:M,config:h})));P.useEffect((()=>{S.start({scale:1,rotation:M,config:h})}),[M]),P.useEffect((()=>(r&&i&&e&&(x.style.cursor="grab",g.domElement.style.cursor=""),()=>{x.style.cursor="default",g.domElement.style.cursor="default"})),[r,i,x,e]);const C=c.useGesture({onHover:({last:t})=>{i&&!r&&e&&(x.style.cursor=t?"auto":"grab")},onDrag:({down:r,delta:[o,a],memo:[s,l]=E.rotation.animation.to||M})=>{if(!e)return[a,o];i&&(x.style.cursor=r?"grabbing":"grab"),o=n.MathUtils.clamp(l+o/y.width*Math.PI*u,...b),a=n.MathUtils.clamp(s+a/y.height*Math.PI*u,...w);const c=t&&!r&&"boolean"!=typeof t?t:h;return S.start({scale:r&&a>w[1]/2?m:1,rotation:t&&!r?M:[a,o,0],config:e=>"scale"===e?{...c,friction:3*c.friction}:c}),[a,o]}},{target:r?x:void 0});return P.createElement(l.a.group,T.default({},null==C?void 0:C(),E),s)},exports.QuadraticBezierLine=de,exports.RandomizedLight=Kr,exports.Reflector=un,exports.RenderTexture=So,exports.Ring=yr,exports.RoundedBox=Dr,exports.Sampler=function({children:e,weight:t,transform:r,instances:n,mesh:o,count:a=16,...i}){const s=P.useRef(null),l=P.useRef(null),c=P.useRef(null);return P.useLayoutEffect((()=>{var e,t;l.current=null!==(e=null==n?void 0:n.current)&&void 0!==e?e:s.current.children.find((e=>e.hasOwnProperty("instanceMatrix"))),c.current=null!==(t=null==o?void 0:o.current)&&void 0!==t?t:s.current.children.find((e=>"Mesh"===e.type))}),[e,null==o?void 0:o.current,null==n?void 0:n.current]),_e(c,a,r,t,l),P.createElement("group",T.default({ref:s},i),e)},exports.ScreenQuad=zr,exports.ScreenSpace=le,exports.Scroll=oe,exports.ScrollControls=function({eps:e=1e-5,enabled:t=!0,infinite:r,horizontal:n,pages:a=1,distance:i=1,damping:l=.25,maxSpeed:c=1/0,style:u={},children:d}){const{get:m,setEvents:f,gl:p,size:h,invalidate:v,events:g}=o.useThree(),[x]=P.useState((()=>document.createElement("div"))),[y]=P.useState((()=>document.createElement("div"))),[w]=P.useState((()=>document.createElement("div"))),b=p.domElement.parentNode,M=P.useRef(0),E=P.useMemo((()=>{const t={el:x,eps:e,fill:y,fixed:w,horizontal:n,damping:l,offset:0,delta:0,scroll:M,pages:a,range(e,t,r=0){const n=e-r,o=n+t+2*r;return this.offset<n?0:this.offset>o?1:(this.offset-n)/(o-n)},curve(e,t,r=0){return Math.sin(this.range(e,t,r)*Math.PI)},visible(e,t,r=0){const n=e-r,o=n+t+2*r;return this.offset>=n&&this.offset<=o}};return t}),[e,l,n,a]);P.useEffect((()=>{x.style.position="absolute",x.style.width="100%",x.style.height="100%",x.style[n?"overflowX":"overflowY"]="auto",x.style[n?"overflowY":"overflowX"]="hidden",x.style.top="0px",x.style.left="0px";for(const e in u)x.style[e]=u[e];w.style.position="sticky",w.style.top="0px",w.style.left="0px",w.style.width="100%",w.style.height="100%",w.style.overflow="hidden",x.appendChild(w),y.style.height=n?"100%":a*i*100+"%",y.style.width=n?a*i*100+"%":"100%",y.style.pointerEvents="none",x.appendChild(y),b.appendChild(x),x[n?"scrollLeft":"scrollTop"]=1;const e=g.connected||p.domElement;requestAnimationFrame((()=>null==g.connect?void 0:g.connect(x)));const t=m().events.compute;return f({compute(e,t){const{left:r,top:n}=b.getBoundingClientRect(),o=e.clientX-r,a=e.clientY-n;t.pointer.set(o/t.size.width*2-1,-a/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{b.removeChild(x),f({compute:t}),null==g.connect||g.connect(e)}}),[a,i,n,x,y,w,b]),P.useEffect((()=>{if(g.connected===x){const e=h[n?"width":"height"],o=x[n?"scrollWidth":"scrollHeight"],a=o-e;let i=0,s=!0,l=!0;const c=()=>{if(t&&!l&&(v(),i=x[n?"scrollLeft":"scrollTop"],M.current=i/a,r)){if(!s)if(i>=a){const e=1-E.offset;x[n?"scrollLeft":"scrollTop"]=1,M.current=E.offset=-e,s=!0}else if(i<=0){const e=1+E.offset;x[n?"scrollLeft":"scrollTop"]=o,M.current=E.offset=e,s=!0}s&&setTimeout((()=>s=!1),40)}};x.addEventListener("scroll",c,{passive:!0}),requestAnimationFrame((()=>l=!1));const u=e=>x.scrollLeft+=e.deltaY/2;return n&&x.addEventListener("wheel",u,{passive:!0}),()=>{x.removeEventListener("scroll",c),n&&x.removeEventListener("wheel",u)}}}),[x,g,h,r,E,v,n,t]);let S=0;return o.useFrame(((t,r)=>{S=E.offset,s.easing.damp(E,"offset",M.current,l,r,c,void 0,e),s.easing.damp(E,"delta",Math.abs(S-E.offset),l,r,c,void 0,e),E.delta>e&&v()})),P.createElement(ee.Provider,{value:E},d)},exports.Segment=go,exports.SegmentObject=ho,exports.Segments=po,exports.Select=function({box:e,multiple:t,children:r,onChange:n,onChangePointerUp:a,border:i="1px solid #55aaff",backgroundColor:s="rgba(75, 160, 255, 0.1)",filter:l=(e=>e),...c}){const[u,m]=P.useState(!1),{setEvents:f,camera:p,raycaster:h,gl:v,controls:g,size:x,get:y}=o.useThree(),[w,b]=P.useState(!1),[M,E]=P.useReducer(((e,{object:t,shift:r})=>void 0===t?[]:Array.isArray(t)?t:r?e.includes(t)?e.filter((e=>e!==t)):[t,...e]:e[0]===t?[]:[t]),[]);P.useEffect((()=>{u?null==n||n(M):null==a||a(M)}),[M,u]);const S=P.useCallback((e=>{e.stopPropagation(),E({object:l([e.object])[0],shift:t&&e.shiftKey})}),[]),C=P.useCallback((e=>!w&&E({})),[w]),R=P.useRef(null);return P.useEffect((()=>{if(!e||!t)return;const r=new d.SelectionBox(p,R.current),n=document.createElement("div");n.style.pointerEvents="none",n.style.border=i,n.style.backgroundColor=s,n.style.position="fixed";const o=new D.Vector2,a=new D.Vector2,c=new D.Vector2,u=y().events.enabled,h=null==g?void 0:g.enabled;let w=!1;function b(e,t){const{offsetX:r,offsetY:n}=e,{width:o,height:a}=x;t.set(r/o*2-1,-n/a*2+1)}function M(e){e.shiftKey&&(!function(e){var t;g&&(g.enabled=!1),f({enabled:!1}),m(w=!0),null==(t=v.domElement.parentElement)||t.appendChild(n),n.style.left=`${e.clientX}px`,n.style.top=`${e.clientY}px`,n.style.width="0px",n.style.height="0px",o.x=e.clientX,o.y=e.clientY}(e),b(e,r.startPoint))}let S=[];function C(e){if(w){!function(e){c.x=Math.max(o.x,e.clientX),c.y=Math.max(o.y,e.clientY),a.x=Math.min(o.x,e.clientX),a.y=Math.min(o.y,e.clientY),n.style.left=`${a.x}px`,n.style.top=`${a.y}px`,n.style.width=c.x-a.x+"px",n.style.height=c.y-a.y+"px"}(e),b(e,r.endPoint);const t=r.select().sort((e=>e.uuid)).filter((e=>e.isMesh));F.default(t,S)||(S=t,E({object:l(t)}))}}function T(e){var t;w&&w&&(g&&(g.enabled=h),f({enabled:u}),m(w=!1),null==(t=n.parentElement)||t.removeChild(n))}return document.addEventListener("pointerdown",M,{passive:!0}),document.addEventListener("pointermove",C,{passive:!0,capture:!0}),document.addEventListener("pointerup",T,{passive:!0}),()=>{document.removeEventListener("pointerdown",M),document.removeEventListener("pointermove",C),document.removeEventListener("pointerup",T)}}),[x.width,x.height,h,p,g,v]),P.createElement("group",T.default({ref:R,onClick:S,onPointerOver:()=>b(!0),onPointerOut:()=>b(!1),onPointerMissed:C},c),P.createElement(ie.Provider,{value:M},r))},exports.Shadow=rn,exports.Shape=Pr,exports.Sky=yn,exports.SoftShadows=function({focus:e=0,samples:t=10,size:r=25}){const n=o.useThree((e=>e.gl)),a=o.useThree((e=>e.scene)),i=o.useThree((e=>e.camera));return P.useEffect((()=>{const o=D.ShaderChunk.shadowmap_pars_fragment;return D.ShaderChunk.shadowmap_pars_fragment=D.ShaderChunk.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP","#ifdef USE_SHADOWMAP\n"+(({focus:e=0,size:t=25,samples:r=10}={})=>`\n#define PENUMBRA_FILTER_SIZE float(${t})\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\nvec3 randRGB(vec2 uv) {\n  return vec3(\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n  );\n}\n\nvec3 lowPassRandRGB(vec2 uv) {\n  // 3x3 convolution (average)\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n  vec3 result = vec3(0);\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n  result *= 0.111111111; // 1.0 / 9.0\n  return result;\n}\nvec3 highPassRandRGB(vec2 uv) {\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n  // hp(x) = x - lp(x)\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n}\n\n\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n  const float goldenAngle = 2.399963f; // radians\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n  float theta = float(sampleIndex) * goldenAngle + angle;\n  float sine = sin(theta);\n  float cosine = cos(theta);\n  return vec2(cosine, sine) * r;\n}\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float blockerDepthSum = float(${e});\n  float blockers = 0.0;\n\n  int j = 0;\n  vec2 offset = vec2(0.);\n  float depth = 0.;\n\n  #pragma unroll_loop_start\n  for(int i = 0; i < ${r}; i ++) {\n    offset = (vogelDiskSample(j, ${r}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n    if (depth < compare) {\n      blockerDepthSum += depth;\n      blockers++;\n    }\n    j++;\n  }\n  #pragma unroll_loop_end\n\n  if (blockers > 0.0) {\n    return blockerDepthSum / blockers;\n  }\n  return -1.0;\n}\n\n        \nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n  float shadow = 0.0f;\n  int j = 0;\n  vec2 vogelSample = vec2(0.0);\n  vec2 offset = vec2(0.0);\n  #pragma unroll_loop_start\n  for (int i = 0; i < ${r}; i++) {\n    vogelSample = vogelDiskSample(j, ${r}, angle) * texelSize;\n    offset = vogelSample * (1.0 + filterRadius * float(${t}));\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n    j++;\n  }\n  #pragma unroll_loop_end\n  return shadow * 1.0 / ${r}.0;\n}\n\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n  if (avgBlockerDepth == -1.0) {\n    return 1.0;\n  }\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n}`)({size:r,samples:t,focus:e})).replace("#if defined( SHADOWMAP_TYPE_PCF )","\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )"),sr(n,a,i),()=>{D.ShaderChunk.shadowmap_pars_fragment=o,sr(n,a,i)}}),[e,r,t]),null},exports.Sparkles=Rn,exports.Sphere=fr,exports.SpotLight=vn,exports.SpotLightShadow=function(e){return e.shader?P.createElement(pn,e):P.createElement(hn,e)},exports.Stage=function({children:e,center:t,adjustCamera:r=!0,intensity:n=.5,shadows:o="contact",environment:a="city",preset:i="rembrandt",...s}){var l,c,u,d,m,f,p,h;const v="string"==typeof i?Jr[i]:i,[{radius:g,height:x},y]=P.useState({radius:0,width:0,height:0,depth:0}),w=null!==(l=null==o?void 0:o.bias)&&void 0!==l?l:-1e-4,b=null!==(c=null==o?void 0:o.normalBias)&&void 0!==c?c:0,M=null!==(u=null==o?void 0:o.size)&&void 0!==u?u:1024,E=null!==(d=null==o?void 0:o.offset)&&void 0!==d?d:0,S="contact"===o||"contact"===(null==o?void 0:o.type),C="accumulative"===o||"accumulative"===(null==o?void 0:o.type),R={..."object"==typeof o?o:{}},D=a?"string"==typeof a?{preset:a}:a:null;return P.createElement(P.Fragment,null,P.createElement("ambientLight",{intensity:n/3}),P.createElement("spotLight",{penumbra:1,position:[v.main[0]*g,v.main[1]*g,v.main[2]*g],intensity:2*n,castShadow:!!o,"shadow-bias":w,"shadow-normalBias":b,"shadow-mapSize":M}),P.createElement("pointLight",{position:[v.fill[0]*g,v.fill[1]*g,v.fill[2]*g],intensity:n}),P.createElement(Br,T.default({fit:!!r,clip:!!r,margin:Number(r),observe:!0},s),P.createElement(en,{radius:g,adjustCamera:r}),P.createElement(_r,T.default({},t,{position:[0,E/2,0],onCentered:e=>{const{width:r,height:n,depth:o,boundingSphere:a}=e;y({radius:a.radius,width:r,height:n,depth:o}),null!=t&&t.onCentered&&t.onCentered(e)}}),e)),P.createElement("group",{position:[0,-x/2-E/2,0]},S&&P.createElement(qr,T.default({scale:4*g,far:g,blur:2},R)),C&&P.createElement(Zr,T.default({temporal:!0,frames:100,alphaTest:.9,toneMapped:!0,scale:4*g},R),P.createElement(Kr,{amount:null!==(m=R.amount)&&void 0!==m?m:8,radius:null!==(f=R.radius)&&void 0!==f?f:g,ambient:null!==(p=R.ambient)&&void 0!==p?p:.5,intensity:null!==(h=R.intensity)&&void 0!==h?h:1,position:[v.main[0]*g,v.main[1]*g,v.main[2]*g],size:4*g,bias:-w,mapSize:M}))),a&&P.createElement($r,D))},exports.Stars=Mn,exports.Stats=function({showPanel:e=0,className:t,parent:r}){const n=function(e,t=[],r){const[n,o]=P.useState();return P.useLayoutEffect((()=>{const t=e();return o(t),It(r,t),()=>It(r,null)}),t),n}((()=>new I.default),[]);return P.useEffect((()=>{if(n){const a=r&&r.current||document.body;n.showPanel(e),null==a||a.appendChild(n.dom),t&&n.dom.classList.add(...t.split(" ").filter((e=>e)));const i=o.addEffect((()=>n.begin())),s=o.addAfterEffect((()=>n.end()));return()=>{null==a||a.removeChild(n.dom),i(),s()}}}),[r,n,t,e]),null},exports.Svg=Ve,exports.Tetrahedron=xr,exports.Text=he,exports.Text3D=ge,exports.Torus=vr,exports.TorusKnot=gr,exports.TrackballControls=Je,exports.Trail=ze,exports.TransformControls=tt,exports.Tube=hr,exports.View=({track:e,index:t=1,frames:r=1/0,children:n})=>{var a,i;const s=P.useRef(null),{size:l,scene:c}=o.useThree(),[u]=P.useState((()=>new D.Scene)),d=P.useCallback(((t,r)=>{if(s.current&&e.current&&t.target===e.current){const{width:e,height:n,left:o,top:a}=s.current,i=t.clientX-o,l=t.clientY-a;r.pointer.set(i/e*2-1,-l/n*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)}}),[s,e]),[m,f]=P.useReducer((()=>!0),!1);return P.useEffect((()=>{var t;s.current=null==(t=e.current)?void 0:t.getBoundingClientRect(),f()}),[e]),P.createElement(P.Fragment,null,m&&o.createPortal(P.createElement(Do,{canvasSize:l,frames:r,scene:c,track:e,rect:s,index:t},n),u,{events:{compute:d,priority:t},size:{width:null==(a=s.current)?void 0:a.width,height:null==(i=s.current)?void 0:i.height}}))},exports.Wireframe=function({geometry:e,...t}){return e?P.createElement(Bn,T.default({geometry:e},t)):P.createElement(An,t)},exports.accumulativeContext=Xr,exports.calcPosFromAngles=xn,exports.calculateScaleFactor=Jo,exports.isWebGL2Available=()=>{try{var e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))}catch(e){return!1}},exports.meshBounds=function(e,t){const r=this.geometry,n=this.material,o=this.matrixWorld;void 0!==n&&(null===r.boundingSphere&&r.computeBoundingSphere(),bo.copy(r.boundingSphere),bo.applyMatrix4(o),!1!==e.ray.intersectsSphere(bo)&&(yo.copy(o).invert(),wo.copy(e.ray).applyMatrix4(yo),null!==r.boundingBox&&null===wo.intersectBox(r.boundingBox,Mo)||t.push({distance:Mo.distanceTo(e.ray.origin),point:Mo.clone(),object:this})))},exports.shaderMaterial=ye,exports.useAnimations=function(e,t){const r=P.useRef(),[a]=P.useState((()=>t?t instanceof n.Object3D?{current:t}:t:r)),[i]=P.useState((()=>new n.AnimationMixer(void 0))),s=P.useRef({}),[l]=P.useState((()=>{const t={};return e.forEach((e=>Object.defineProperty(t,e.name,{enumerable:!0,get(){if(a.current)return s.current[e.name]||(s.current[e.name]=i.clipAction(e,a.current))}}))),{ref:a,clips:e,actions:t,names:e.map((e=>e.name)),mixer:i}}));return o.useFrame(((e,t)=>i.update(t))),P.useEffect((()=>{const e=a.current;return()=>{s.current={},Object.values(l.actions).forEach((t=>{e&&i.uncacheAction(t,e)}))}}),[e]),P.useEffect((()=>()=>{i.stopAllAction()}),[i]),l},exports.useAspect=function(e,t,r=1){const n=o.useThree((e=>e.viewport)),a=t*(n.aspect>e/t?n.width/e:n.height/t);return[e*(n.aspect>e/t?n.width/e:n.height/t)*r,a*r,1]},exports.useBVH=function(e,t){t={strategy:b.SAH,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,...t},P.useEffect((()=>{if(e.current){e.current.raycast=b.acceleratedRaycast;const r=e.current.geometry;return r.computeBoundsTree=b.computeBoundsTree,r.disposeBoundsTree=b.disposeBoundsTree,r.computeBoundsTree(t),()=>{r.boundsTree&&r.disposeBoundsTree()}}}),[e,JSON.stringify(t)])},exports.useBounds=Ar,exports.useBoxProjectedEnv=function(e=new D.Vector3,t=new D.Vector3){const[r]=P.useState((()=>({position:new D.Vector3,size:new D.Vector3})));o.applyProps(r,{position:e,size:t});const n=P.useRef(null),a=P.useMemo((()=>({ref:n,onBeforeCompile:e=>function(e,t,r){e.defines.BOX_PROJECTED_ENV_MAP=!0,e.uniforms.envMapPosition={value:t},e.uniforms.envMapSize={value:r},e.vertexShader=`\n  varying vec3 vWorldPosition;\n  ${e.vertexShader.replace("#include <worldpos_vertex>","\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n  #ifdef BOX_PROJECTED_ENV_MAP\n    vWorldPosition = worldPosition.xyz;\n  #endif\n#endif\n")}`,e.fragmentShader=`\n    \n#ifdef BOX_PROJECTED_ENV_MAP\n  uniform vec3 envMapSize;\n  uniform vec3 envMapPosition;\n  varying vec3 vWorldPosition;\n    \n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n    vec3 nDir = normalize( v );\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbminmax;\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \n    return boxIntersection - cubePos;\n  }\n#endif\n\n    ${e.fragmentShader.replace("#include <envmap_physical_pars_fragment>",D.ShaderChunk.envmap_physical_pars_fragment).replace("vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );","vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n         \n#ifdef BOX_PROJECTED_ENV_MAP\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n\n         ").replace("reflectVec = inverseTransformDirection( reflectVec, viewMatrix );","reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n         \n#ifdef BOX_PROJECTED_ENV_MAP\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n\n        ")}`}(e,r.position,r.size),customProgramCacheKey:()=>JSON.stringify(r.position.toArray())+JSON.stringify(r.size.toArray())})),[...r.position.toArray(),...r.size.toArray()]);return P.useLayoutEffect((()=>{n.current.needsUpdate=!0}),[r]),a},exports.useCamera=function(e,t){const r=o.useThree((e=>e.pointer)),[a]=P.useState((()=>{const a=new n.Raycaster;return t&&o.applyProps(a,t,{}),function(t,o){a.setFromCamera(r,e instanceof n.Camera?e:e.current);const i=this.constructor.prototype.raycast.bind(this);i&&i(a,o)}}));return a},exports.useContextBridge=function(...e){const t=P.useRef([]);return t.current=e.map((e=>P.useContext(e))),P.useMemo((()=>({children:r})=>e.reduceRight(((e,r,n)=>P.createElement(r.Provider,{value:t.current[n],children:e})),r)),[])},exports.useCubeCamera=Xe,exports.useCubeTexture=Ft,exports.useCursor=function(e,t="pointer",r="auto"){P.useEffect((()=>{if(e)return document.body.style.cursor=t,()=>{document.body.style.cursor=r}}),[e])},exports.useDepthBuffer=function({size:e=256,frames:t=1/0}={}){const r=o.useThree((e=>e.viewport.dpr)),{width:a,height:i}=o.useThree((e=>e.size)),s=e||a*r,l=e||i*r,c=P.useMemo((()=>{const e=new n.DepthTexture(s,l);return e.format=n.DepthFormat,e.type=n.UnsignedShortType,{depthTexture:e}}),[s,l]);let u=0;const d=He(s,l,c);return o.useFrame((e=>{(t===1/0||u<t)&&(e.gl.setRenderTarget(d),e.gl.render(e.scene,e.camera),e.gl.setRenderTarget(null),u++)})),d.depthTexture},exports.useDetectGPU=e=>p.suspend((()=>w.getGPUTier(e)),["useDetectGPU"]),exports.useEnvironment=Vr,exports.useFBO=He,exports.useFBX=Lt,exports.useGLTF=Ne,exports.useGizmoContext=lt,exports.useHelper=Ut,exports.useIntersect=function(e){const t=P.useRef(null),r=P.useRef(!1),n=P.useRef(!1),a=P.useRef(e);return P.useLayoutEffect((()=>{a.current=e}),[e]),P.useEffect((()=>{const e=t.current;if(e){const t=o.addEffect((()=>(r.current=!1,!0))),i=e.onBeforeRender;e.onBeforeRender=()=>r.current=!0;const s=o.addAfterEffect((()=>(r.current!==n.current&&(null==a.current||a.current(n.current=r.current)),!0)));return()=>{e.onBeforeRender=i,t(),s()}}}),[]),t},exports.useKTX2=At,exports.useKeyboardControls=function(e){const[t,r,n]=P.useContext(ae);return e?n(e):[t,r]},exports.useMask=function(e,t=!1){return{stencilWrite:!0,stencilRef:e,stencilFunc:t?D.NotEqualStencilFunc:D.EqualStencilFunc,stencilFail:D.KeepStencilOp,stencilZFail:D.KeepStencilOp,stencilZPass:D.KeepStencilOp}},exports.useMatcapTexture=function(e=0,t=1024,r){const n=p.suspend((()=>fetch("https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json").then((e=>e.json()))),["matcapList"]),o=n[0],a=P.useMemo((()=>Object.keys(n).length),[]),i=`${P.useMemo((()=>"string"==typeof e?e:"number"==typeof e?n[e]:null),[e])||o}${function(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}(t)}.png`,s=`https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d/${t}/${i}`;return[be(s,r),s,a]},exports.useNormalTexture=function(e=0,t={},r){const{repeat:o=[1,1],anisotropy:a=1,offset:i=[0,0]}=t,s=p.suspend((()=>fetch("https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json").then((e=>e.json()))),["normalsList"]),l=P.useMemo((()=>Object.keys(s).length),[]),c=s[0],u=`https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb/normals/${s[e]||c}`,d=be(u,r);return P.useLayoutEffect((()=>{d&&(d.wrapS=d.wrapT=n.RepeatWrapping,d.repeat=new n.Vector2(o[0],o[1]),d.offset=new n.Vector2(i[0],i[1]),d.anisotropy=a)}),[d,a,o,i]),[d,u,l]},exports.usePerformanceMonitor=function({onIncline:e,onDecline:r,onChange:n,onFallback:o}){const a=t.useContext(Eo),i=t.useRef({onIncline:e,onDecline:r,onChange:n,onFallback:o});t.useLayoutEffect((()=>{i.current.onIncline=e,i.current.onDecline=r,i.current.onChange=n,i.current.onFallback=o}),[e,r,n,o]),t.useLayoutEffect((()=>a.subscribe(i)),[a])},exports.useProgress=K,exports.useScroll=te,exports.useSelect=function(){return P.useContext(ie)},exports.useSurfaceSampler=_e,exports.useTexture=be,exports.useTrail=ke,exports.useTrailTexture=function(e={}){const{size:r,maxAge:n,radius:a,intensity:i,interpolate:s,smoothing:l,minForce:c,blend:u,ease:d}=e,m=t.useMemo((()=>new Gt(e)),[r,n,a,i,s,l,c,u,d]);o.useFrame(((e,t)=>{m.update(t)}));const f=t.useCallback((e=>m.addTouch(e.uv)),[m]);return[m.texture,f]},exports.useVideoTexture=function(e,r){const{unsuspend:n,start:a,crossOrigin:i,muted:s,loop:l,...c}={unsuspend:"loadedmetadata",crossOrigin:"Anonymous",muted:!0,loop:!0,start:!0,playsInline:!0,...r},u=o.useThree((e=>e.gl)),d=p.suspend((()=>new Promise(((t,r)=>{const o=Object.assign(document.createElement("video"),{src:"string"==typeof e&&e||void 0,srcObject:e instanceof MediaStream&&e||void 0,crossOrigin:i,loop:l,muted:s,...c}),a=new D.VideoTexture(o);a.encoding=u.outputEncoding,o.addEventListener(n,(()=>t(a)))}))),[e]);return t.useEffect((()=>{a&&d.image.play()}),[d,a]),d};
